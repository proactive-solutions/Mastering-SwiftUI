<!DOCTYPE HTML>
<html lang="zh-tw" >
    
    <head>
        
        <meta charset=utf-8"UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=11; IE=10; IE=9; IE=8; IE=7; IE=EDGE" />
        <title>使用手势与动画建立 Tinder 风格的 UI | 精通 SwiftUI - iOS 16 版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.0.1">
        <meta name="author" content="Simon Ng">
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    <link rel="next" href="./swiftui-advanced-animations.html" />
    
    
    <link rel="prev" href="./swiftui-bottom-sheet.html" />
    

        
    </head>
    <body>
        
        
    <link rel="stylesheet" href="gitbook/style.css">
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-image-captions/image-captions.css">
        
    
    
        <link rel="stylesheet" href="././styles/website.css">
    

        
    <div class="book" data-level="19" data-basepath="." data-revision="Thu Dec 01 2022 17:36:55 GMT+0800 (HKT)">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="输入并搜寻" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
            
            <li>
                <a href="https://www.appcoda.com.tw" target="blank" class="custom-link">Made by AppCoda</a>
            </li>
        
            
            <li>
                <a href="https://www.appcoda.com.tw/contact" target="blank" class="custom-link">Contact us / Support</a>
            </li>
        
            
            <li>
                <a href="http://twitter.com/share?text=Mastering%20SwiftUI%20via%20@appcodamobile&amp;url=https://www.appcoda.com.tw/swiftui/&amp;hashtags=swiftlang" target="blank" class="custom-link">Tweet this book</a>
            </li>
        
        

        
        <li class="divider"></li>
        

        
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                        <i class="fa fa-check"></i>
                        
                        序言
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="swiftui-basics.html">
            
                
                    <a href="./swiftui-basics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        SwiftUI 介绍
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="swiftui-text.html">
            
                
                    <a href="./swiftui-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        SwiftUI 入门 - 文字的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="swiftui-images.html">
            
                
                    <a href="./swiftui-images.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        图片的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="4" data-path="swiftui-stacks.html">
            
                
                    <a href="./swiftui-stacks.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        以堆叠布局使用者介面
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="5" data-path="swiftui-scrollview.html">
            
                
                    <a href="./swiftui-scrollview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        ScrollView 与 Carousel UI 的建立
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="6" data-path="swiftui-buttons.html">
            
                
                    <a href="./swiftui-buttons.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                        SwiftUI 按钮与渐层
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="7" data-path="swiftui-state.html">
            
                
                    <a href="./swiftui-state.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                        状态(State)与绑定(Binding)
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="8" data-path="swiftui-path-shape.html">
            
                
                    <a href="./swiftui-path-shape.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                        实现路径(Path)与形状(Shape)来画线与圆饼图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="9" data-path="swiftui-animation.html">
            
                
                    <a href="./swiftui-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                        基础动画与转场
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="10" data-path="swiftui-list.html">
            
                
                    <a href="./swiftui-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                        动态列表、 ForEach 与 Identifiable 的使用方法
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="11" data-path="swiftui-navigation.html">
            
                
                    <a href="./swiftui-navigation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                        导览UI与导览列客制化运用
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="12" data-path="swiftui-modal.html">
            
                
                    <a href="./swiftui-modal.html">
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                        强制回应视图、浮动按钮与提示的实现
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="13" data-path="swiftui-form.html">
            
                
                    <a href="./swiftui-form.html">
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                        以选取器(Picker)、开关(Toggle)与步进器(Stepper)来建立一个表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="14" data-path="swiftui-form-data.html">
            
                
                    <a href="./swiftui-form-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                        使用 Combine 与 Environment 物件进行资料分享
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="15" data-path="swiftui-form-registration.html">
            
                
                    <a href="./swiftui-form-registration.html">
                        <i class="fa fa-check"></i>
                        
                            <b>15.</b>
                        
                        以 Combine 与 视图模型建立一个注册表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="16" data-path="swiftui-actionsheet-context.html">
            
                
                    <a href="./swiftui-actionsheet-context.html">
                        <i class="fa fa-check"></i>
                        
                            <b>16.</b>
                        
                        滑动删除、内容选单与动作列表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="17" data-path="swiftui-gestures.html">
            
                
                    <a href="./swiftui-gestures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>17.</b>
                        
                        认识手势（Gestures）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="18" data-path="swiftui-bottom-sheet.html">
            
                
                    <a href="./swiftui-bottom-sheet.html">
                        <i class="fa fa-check"></i>
                        
                            <b>18.</b>
                        
                        以SwiftUI 手势与 GeometryReader 建立一个底部展开式页面
                    </a>
                
            
            
        </li>
    
        <li class="chapter active" data-level="19" data-path="swiftui-trip-tinder.html">
            
                
                    <a href="./swiftui-trip-tinder.html">
                        <i class="fa fa-check"></i>
                        
                            <b>19.</b>
                        
                        使用手势与动画建立 Tinder 风格的 UI
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="20" data-path="swiftui-advanced-animations.html">
            
                
                    <a href="./swiftui-advanced-animations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>20.</b>
                        
                        建立像 Apple Wallet App 的动画和转场效果
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="21" data-path="swiftui-json.html">
            
                
                    <a href="./swiftui-json.html">
                        <i class="fa fa-check"></i>
                        
                            <b>21.</b>
                        
                        JSON、滑杆的运用与资料过滤
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="22" data-path="swiftui-core-data.html">
            
                
                    <a href="./swiftui-core-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>22.</b>
                        
                        如何使用 Core Data 建立 ToDo App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="23" data-path="swiftui-uikit.html">
            
                
                    <a href="./swiftui-uikit.html">
                        <i class="fa fa-check"></i>
                        
                            <b>23.</b>
                        
                        利用 UIViewRepresentable 整合UIKit 组件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="24" data-path="swiftui-searchbar.html">
            
                
                    <a href="./swiftui-searchbar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>24.</b>
                        
                        建立搜寻栏视图并使用自订绑定（Custom Binding）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="25" data-path="swiftui-real-world-app.html">
            
                
                    <a href="./swiftui-real-world-app.html">
                        <i class="fa fa-check"></i>
                        
                            <b>25.</b>
                        
                        把所学应用出来！构建个人理财App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="26" data-path="swiftui-appstoreanimation.html">
            
                
                    <a href="./swiftui-appstoreanimation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>26.</b>
                        
                        创建类似App Store使用的动画视图转换
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="27" data-path="swiftui-carousel.html">
            
                
                    <a href="./swiftui-carousel.html">
                        <i class="fa fa-check"></i>
                        
                            <b>27.</b>
                        
                        如何建立图像轮播（Image Carousel）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="28" data-path="swiftui-expandable-list.html">
            
                
                    <a href="./swiftui-expandable-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>28.</b>
                        
                        如何建立展开式列表视图和大纲视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="29" data-path="swiftui-gridlayout.html">
            
                
                    <a href="./swiftui-gridlayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>29.</b>
                        
                        使用 LazyVGrid 和 LazyHGrid 构建集合视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="30" data-path="swiftui-progress-ring.html">
            
                
                    <a href="./swiftui-progress-ring.html">
                        <i class="fa fa-check"></i>
                        
                            <b>30.</b>
                        
                        使用 Shape 和 Animatable 开发带动画的环形进度条
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="31" data-path="swiftui-library.html">
            
                
                    <a href="./swiftui-library.html">
                        <i class="fa fa-check"></i>
                        
                            <b>31.</b>
                        
                        如何使用 AnimatableModifier 和 LibraryContentProvider
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="32" data-path="swiftui-texteditor.html">
            
                
                    <a href="./swiftui-texteditor.html">
                        <i class="fa fa-check"></i>
                        
                            <b>32.</b>
                        
                        使用 TextEditor 支持多行文字输入
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="33" data-path="swiftui-matchedgeometry.html">
            
                
                    <a href="./swiftui-matchedgeometry.html">
                        <i class="fa fa-check"></i>
                        
                            <b>33.</b>
                        
                        使用 matchedGeometryEffect为 App 建立绚丽的视图动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="34" data-path="swiftui-grid-animation.html">
            
                
                    <a href="./swiftui-grid-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>34.</b>
                        
                        ScrollViewReader 和网格动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="35" data-path="swiftui-tabview.html">
            
                
                    <a href="./swiftui-tabview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>35.</b>
                        
                        标签视图的运用与自订标签列
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="36" data-path="swiftui-asyncimage.html">
            
                
                    <a href="./swiftui-asyncimage.html">
                        <i class="fa fa-check"></i>
                        
                            <b>36.</b>
                        
                        利用 AsyncImage 非同步加载和显示图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="37" data-path="swiftui-searchable.html">
            
                
                    <a href="./swiftui-searchable.html">
                        <i class="fa fa-check"></i>
                        
                            <b>37.</b>
                        
                        利用 Searchable 建立搜寻栏
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="38" data-path="swiftui-charts.html">
            
                
                    <a href="./swiftui-charts.html">
                        <i class="fa fa-check"></i>
                        
                            <b>38.</b>
                        
                        利用 Charts 框架建立图表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="39" data-path="swiftui-live-text.html">
            
                
                    <a href="./swiftui-live-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>39.</b>
                        
                        利用 Live Text API 从图片中撷取文本
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="40" data-path="swiftui-sharelink.html">
            
                
                    <a href="./swiftui-sharelink.html">
                        <i class="fa fa-check"></i>
                        
                            <b>40.</b>
                        
                        透过 ShareLink 来分享文本和图像等资料
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="41" data-path="swiftui-imagerenderer.html">
            
                
                    <a href="./swiftui-imagerenderer.html">
                        <i class="fa fa-check"></i>
                        
                            <b>41.</b>
                        
                        利用 ImageRenderer API 轻松把 SwiftUI 视图转换为图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="42" data-path="swiftui-pdf-doc.html">
            
                
                    <a href="./swiftui-pdf-doc.html">
                        <i class="fa fa-check"></i>
                        
                            <b>42.</b>
                        
                        如何把 SwiftUI 视图转换为 PDF 文件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="43" data-path="swiftui-gauge.html">
            
                
                    <a href="./swiftui-gauge.html">
                        <i class="fa fa-check"></i>
                        
                            <b>43.</b>
                        
                        使用 Gauge 视图显示进度并创建速度计
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="44" data-path="swiftui-grid.html">
            
                
                    <a href="./swiftui-grid.html">
                        <i class="fa fa-check"></i>
                        
                            <b>44.</b>
                        
                        使用Grid API 创建网格布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="45" data-path="swiftui-anylayout.html">
            
                
                    <a href="./swiftui-anylayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>45.</b>
                        
                        利用 AnyLayout 切换 UI 布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="46" data-path="swiftui-navigationstack.html">
            
                
                    <a href="./swiftui-navigationstack.html">
                        <i class="fa fa-check"></i>
                        
                            <b>46.</b>
                        
                        使用新的 NavigationStack 视图构建资料导向的导航
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                本书使用 GitBook 释出
            </a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="目录"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="搜寻"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="字型设定"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">衬线体</button>
        <button type="button" data-font="1" class="button">无衬线体</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">白色</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">棕褐色</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">夜间</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="分享"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">
                    分享到 Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    分享到 Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    分享到 Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    分享到 Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    分享到 Instapaper
                </button>
            </div>
        </div>
    </div>
    

    
    
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >精通 SwiftUI - iOS 16 版</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="%E7%AC%AC-19-%E7%AB%A0-br-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%8B%A2%E8%88%87%E5%8B%95%E7%95%AB%E5%BB%BA%E7%AB%8B%E5%A6%82-tinder-%E8%88%AC%E7%9A%84-ui">第 19 章<br>使用手势与动画建立如 Tinder 般的 UI</h1>
<p>建立一个展开式底部表不是很有趣呢？我们来继续应用我们所学到的手势，并将其应用到真实世界的项目中。我不确定你之前是否用过 Tinder App，但是在一些其他 App 中， 你可能会碰到如 Tinder 般的使用者介面。滑动动作是 Tinder UI 的设计重点，并已成为最流行的行动装置 UI 模式之一。使用者向右滑动即表示喜欢某张图片，向左滑动则表示不喜欢。</p>
<p>在本章中，我们要做的是建立一个具有如 Tinder 般UI 的简单 App。这个 App 向使用者显示一副旅游卡，并让他们使用滑动手势来表示喜欢/ 不喜欢一张卡片。</p>
<figure id="fig19.1"><img src="images/triptinder/swiftui-trip-tinder-1.jpg" alt="图 19.1.　建立如Tinder 般的使用者介面"><figcaption>图 19.1.　建立如Tinder 般的使用者介面</figcaption></figure>
<p>请注意，我们将不会建立一个功能齐全的App，而是只着眼于如Tinder 般的UI 。</p>
<h3 id="%E5%B0%88%E6%A1%88%E6%BA%96%E5%82%99">项目准备</h3>
<p>如果你使用自己的图片，那就太棒了。不过，为了节省你准备旅游图片的时间，我已经为你建立了一个起始项目，你可以至下列网址下载：<a href="https://www.appcoda.com/resources/swiftui4/SwiftUITinderTripStarter.zip" target="_blank">https://www.appcoda.com/resources/swiftui4/SwiftUITinderTripStarter.zip</a>。这个项目已经具有一组旅游卡的照片，如图 19.2 所示。</p>
<figure id="fig19.2"><img src="images/triptinder/swiftui-trip-tinder-2.png" alt="图 19.2.　预载了一组旅游照片"><figcaption>图 19.2.　预载了一组旅游照片</figcaption></figure>
<p>除此之外，我已经为范例 App 准备测试资料，并建立了 Trip.swift 档来代表旅程： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trip</span> </span>{
    <span class="hljs-keyword">var</span> destination: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> image: <span class="hljs-type">String</span>
}

#<span class="hljs-keyword">if</span> <span class="hljs-type">DEBUG</span>
<span class="hljs-keyword">var</span> trips = [ <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Yosemite, USA&quot;</span>, image: <span class="hljs-string">&quot;yosemite-usa&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Venice, Italy&quot;</span>, image: <span class="hljs-string">&quot;venice-italy&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Hong Kong&quot;</span>, image: <span class="hljs-string">&quot;hong-kong&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Barcelona, Spain&quot;</span>, image: <span class="hljs-string">&quot;barcelona-spain&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Braies, Italy&quot;</span>, image: <span class="hljs-string">&quot;braies-italy&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Kanangra, Australia&quot;</span>, image: <span class="hljs-string">&quot;kanangra-australia&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Mount Currie, Canada&quot;</span>, image: <span class="hljs-string">&quot;mount-currie-canada&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Ohrid, Macedonia&quot;</span>, image: <span class="hljs-string">&quot;ohrid-macedonia&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Oia, Greece&quot;</span>, image: <span class="hljs-string">&quot;oia-greece&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Palawan, Philippines&quot;</span>, image: <span class="hljs-string">&quot;palawan-philippines&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Salerno, Italy&quot;</span>, image: <span class="hljs-string">&quot;salerno-italy&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Tokyo, Japan&quot;</span>, image: <span class="hljs-string">&quot;tokyo-japan&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;West Vancouver, Canada&quot;</span>, image: <span class="hljs-string">&quot;west-vancouver-canada&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Singapore&quot;</span>, image: <span class="hljs-string">&quot;garden-by-bay-singapore&quot;</span>),
              <span class="hljs-type">Trip</span>(destination: <span class="hljs-string">&quot;Perhentian Islands, Malaysia&quot;</span>, image: <span class="hljs-string">&quot;perhentian-islands-malaysia&quot;</span>)
            ]
#endif
</code></pre>
<p>假如你希望使用自己的图片与资料，则只需替换素材目录中的图片，并更新 <code>Trip.swift</code> 档。</p>
<h3 id="%E5%BB%BA%E7%AB%8B%E5%8D%A1%E7%89%87%E8%A6%96%E5%9C%96%E8%88%87%E9%81%B8%E5%96%AE%E5%88%97">建立卡片视图与选单列</h3>
<p>在实现滑动功能之前，我们先建立主UI，我将主荧幕分成三个部分，如图 19.3 所示： </p>
<ol>
<li>顶部选单列（top menu bar）。</li>
<li>顶部选单列（top menu bar）。</li>
<li>底部选单列（bottom menu bar）。</li>
</ol>
<figure id="fig19.3"><img src="images/triptinder/swiftui-trip-tinder-3.png" alt="图 19.3.　主荧幕"><figcaption>图 19.3.　主荧幕</figcaption></figure>
<h4 id="%E5%8D%A1%E7%89%87%E8%A6%96%E5%9C%96">卡片视图</h4>
<p>首先，我们建立一个卡片视图。若是你想挑战自我，我强烈建议你在这里停下来并实现它，而无须遵循本节内容，否则请继续阅读。</p>
<p>为了让代码更易编写，我们将在一个单独的档案中实现卡片视图。在项目导览器中，使用“SwiftUI View”模板来建立新档，并将其命名为 <code>CardView.swift</code>。</p>
<p><code>CardView</code> 是设计用来显示不同的照片与标题，因此声明两个变量来储存这些资料：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> image: <span class="hljs-type">String</span>
<span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>
</code></pre>
<p>主荧幕将显示一副卡片视图。稍后，我们将使用 <code>ForEach</code> 来逐一执行卡片视图数组并显示它们。如果你还记得<code>ForEach</code> 的用法，那么 SwiftUI 需要知道如何唯一识别数组中的每个项目。因此，我们将使 <code>CardView</code> 遵循<code>Identifiable</code> 协定，并导入一个 <code>id</code> 变量，如下所示： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CardView</span>: <span class="hljs-title">View</span>, <span class="hljs-title">Identifiable</span> </span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> image: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>

    .
    .
    .
}
</code></pre>
<p>如果您忘记什么是 <code>Identifiable</code> 协定，则请参考第 10 章。</p>
<p>现在，我们继续实现卡片视图，并更新 <code>body</code> 变量如下： </p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    <span class="hljs-type">Image</span>(image)
        .resizable()
        .scaledToFill()
        .frame(minWidth: <span class="hljs-number">0</span>, maxWidth: .infinity)
        .cornerRadius(<span class="hljs-number">10</span>)
        .padding(.horizontal, <span class="hljs-number">15</span>)
        .overlay(alignment: .bottom) {
            <span class="hljs-type">VStack</span> {

                <span class="hljs-type">Text</span>(title)
                    .font(.system(.headline, design: .rounded))
                    .fontWeight(.bold)
                    .padding(.horizontal, <span class="hljs-number">30</span>)
                    .padding(.vertical, <span class="hljs-number">10</span>)
                    .background(<span class="hljs-type">Color</span>.white)
                    .cornerRadius(<span class="hljs-number">5</span>)
            }
            .padding([.bottom], <span class="hljs-number">20</span>)
        }
}
</code></pre>
<p>卡片视图是由一张图片及一个叠在图片上方的文字元件所组成。我们设定图片为 <code>scaleToFill</code> 模式，并使用 <code>cornerRadius</code> 修饰器来为图片加上圆角。文字元件是用来显示旅程的目的地。</p>
<p>我们在第 5 章中深入讨论过卡片视图的类似实现。如果你不能完全了解代码，则请再次阅读该章。</p>
<p>你还无法预览卡片视图，因为你必须在 <code>CardView_Previews</code> 中同时提供 <code>image</code> 与 <code>title</code> 的值，因此更新<code>CardView_Previews</code> 结构如下： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CardView_Previews</span>: <span class="hljs-title">PreviewProvider</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">CardView</span>(image: <span class="hljs-string">&quot;yosemite-usa&quot;</span>, title: <span class="hljs-string">&quot;Yosemite, USA&quot;</span>)
    }
}
</code></pre>
<p>我只是使用素材目录中的其中一张图片来进行预览，你可以依自己的需求随意更改图片及标题。在预览画布中，你现在应该看到类似图 19.4 的卡片视图。</p>
<figure id="fig19.4"><img src="images/triptinder/swiftui-trip-tinder-4.png" alt="图 19.4.　预览卡片视图"><figcaption>图 19.4.　预览卡片视图</figcaption></figure>
<h4 id="%E9%81%B8%E5%96%AE%E5%88%97%E8%88%87%E4%B8%BB-ui">选单列与主 UI</h4>
<p>准备好卡片视图后，我们可以继续实现主 UI。如前所述，主 UI 有卡片与两个选单列， 对于这两个选单列，我将为它们个别建立一个单独的 <code>struct</code>。</p>
<p>现在开启 <code>ContentView.swift</code> 并开始实现。对于顶部选单列，建立一个新的 <code>struct</code>，如下所示： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TopBarMenu</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">HStack</span> {
            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;line.horizontal.3&quot;</span>)
                .font(.system(size: <span class="hljs-number">30</span>))
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;mappin.and.ellipse&quot;</span>)
            .font(.system(size: <span class="hljs-number">35</span>))
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;heart.circle.fill&quot;</span>)
            .font(.system(size: <span class="hljs-number">30</span>))
        }
        .padding()
    }
}
</code></pre>
<p>这三个图示使用等距的水平堆叠来排列。对于底部选单列，实现几乎相同。在 <code>Content View.swift</code>  中插入下列的代码，以建立选单列： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BottomBarMenu</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">HStack</span> {
            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;xmark&quot;</span>)
                .font(.system(size: <span class="hljs-number">30</span>))
                .foregroundColor(.black)

            <span class="hljs-type">Button</span> {
                <span class="hljs-comment">// 预定旅程</span>
            } label: {
                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;BOOK IT NOW&quot;</span>)
                    .font(.system(.subheadline, design: .rounded))
                .bold()
                    .foregroundColor(.white)
                    .padding(.horizontal, <span class="hljs-number">35</span>)
                    .padding(.vertical, <span class="hljs-number">15</span>)
                    .background(<span class="hljs-type">Color</span>.black)
                    .cornerRadius(<span class="hljs-number">10</span>)
            }
            .padding(.horizontal, <span class="hljs-number">20</span>)

            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;heart&quot;</span>)
                .font(.system(size: <span class="hljs-number">30</span>))
                .foregroundColor(.black)
        }

    }
}
</code></pre>
<p>我们不打算实现“Book Trip”功能，因此将动作区块留空。假设你了解堆叠与图片的工作原理，则其余的代码应该无需解释。</p>
<p>在建立主UI 之前，让我教你一个预览这两个选单列的技巧。而在 <code>ContentView</code> 中放置这些列，来预览它们的外观及感觉，并不是强制的。</p>
<p>现在更新 <code>ContentView_Previews</code> 结构如下： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView_Previews</span>: <span class="hljs-title">PreviewProvider</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ContentView</span>()

        <span class="hljs-type">TopBarMenu</span>()
            .previewDisplayName(<span class="hljs-string">&quot;TopBarMenu&quot;</span>)

        <span class="hljs-type">BottomBarMenu</span>()
            .previewDisplayName(<span class="hljs-string">&quot;BottomBarMenu&quot;</span>)
    }
}
</code></pre>
<p>这里，我们使用 <code>Group</code> 来将多个元件的预览进行分组。不指定任何的预览选项（如ContentView），Xcode 会在目前模拟器上显示预览。对于 <code>TopBarMenu</code> 与 <code>BottomBarMenu</code>， 我们告诉 Xcode 在容器视图中预览布局，图19.5 可让你更加了解预览是什么样。</p>
<figure id="fig19.5"><img src="images/triptinder/swiftui-trip-tinder-5.png" alt="图 19.5　预览选单列"><figcaption>图 19.5　预览选单列</figcaption></figure>
<p>好的，我们继续布局主UI。更新 <code>ContentView</code> 如下： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">TopBarMenu</span>()

            <span class="hljs-type">CardView</span>(image: <span class="hljs-string">&quot;yosemite-usa&quot;</span>, title: <span class="hljs-string">&quot;Yosemite, USA&quot;</span>)

            <span class="hljs-type">Spacer</span>(minLength: <span class="hljs-number">20</span>)

            <span class="hljs-type">BottomBarMenu</span>()
        }
    }
}
</code></pre>
<p>在代码中，我们只安排了使用 <code>VStack</code> 建立的 UI 元件。你的预览现在应该显示主荧幕了，如图 19.6 所示。</p>
<figure id="fig19.6"><img src="images/triptinder/swiftui-trip-tinder-6.png" alt="图 19.6.　预览主 UI"><figcaption>图 19.6.　预览主 UI</figcaption></figure>
<h3 id="%E5%AF%A6%E4%BD%9C%E5%8D%A1%E7%89%87%E5%BA%AB">实现卡片库</h3>
<p>在做好所有的准备之后，终于可以实现如 Tinder 般的 UI。对于之前从未用过 Tinder App 的人，让我先解释一下如 Tinder 般 UI 的工作原理。</p>
<p>你可以将 Tinder 般 UI 想像为一副成堆的卡片，每张卡片都显示一张照片。在我们的范例 App 中，照片是旅程的目的地。将最上面的卡片（即第一个旅程）轻微向左或向右滑动，即可揭示下一张卡片（即下一个旅程）。如果使用者放开卡片，App 就会将卡片带回原来的位置。不过，当使用者用力滑动时，他/ 她可以丢掉这张卡片，然后App 会将第二张卡片向前移动，成为最上面的卡片，如图 19.7 所示。</p>
<figure id="fig19.7"><img src="images/triptinder/swiftui-trip-tinder-7.jpg" alt="图 19.7.　Tinder 般 UI 的工作原理"><figcaption>图 19.7.　Tinder 般 UI 的工作原理</figcaption></figure>
<p>我们实现的主荧幕只包含一个卡片视图，那么我们如何实现一堆卡片视图呢？ </p>
<p>最直截了当的方式是，使用 <code>ZStack</code> 将每个卡片视图互相堆叠，我们来试着做这个。更新 <code>ContentView</code> 结构如下： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{

    <span class="hljs-keyword">var</span> cardViews: [<span class="hljs-type">CardView</span>] = {

        <span class="hljs-keyword">var</span> views = [<span class="hljs-type">CardView</span>]()

        <span class="hljs-keyword">for</span> trip <span class="hljs-keyword">in</span> trips {
            views.append(<span class="hljs-type">CardView</span>(image: trip.image, title: trip.destination))
        }

        <span class="hljs-keyword">return</span> views
    }()

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">TopBarMenu</span>()

            <span class="hljs-type">ZStack</span> {
                <span class="hljs-type">ForEach</span>(cardViews) { cardView <span class="hljs-keyword">in</span>
                    cardView
                }
            }

            <span class="hljs-type">Spacer</span>(minLength: <span class="hljs-number">20</span>)

            <span class="hljs-type">BottomBarMenu</span>()
        }
    }
}
</code></pre>
<p>在上面的代码中，我们初始化一个包含所有旅程的 <code>cardViews</code> 数组（其在 <code>Trip.swift</code> 档中定义）。在body 变量中，我们逐一执行所有的卡片视图，并将它们包裹在 <code>ZStack</code> 中来相互重叠。</p>
<p>预览画布应该会显示相同的UI，但使用另一张图片，如图19.8 所示。</p>
<figure id="fig19.8"><img src="images/triptinder/swiftui-trip-tinder-8.png" alt="图 19.8.　建立卡片视图库"><figcaption>图 19.8.　建立卡片视图库</figcaption></figure>
<p>为什么它会显示另一张图片呢？如果你引用在 <code>Trip.swift</code> 中定义的 <code>trips</code> 数组，图片是数组的最后一个元素。在<code>ForEach</code> 区块中，第一个旅程是放在卡片库的最下面，如此最后一个旅程便成为卡片库的最上面照片。</p>
<p>当我们实现卡片库时，实际上有两个问题： </p>
<ol>
<li>.<code>trips</code> 数组的第一个旅程应该是最上面的卡片，但是现在却是最下面的卡片。 </li>
<li>我们为 15 个旅程渲染了 15 个卡片视图。如果未来有 10,000 个旅程，甚至更多时，该怎么办呢？我们是否应该为每个旅程建立一个卡片视图呢？有没有高效率的方式来实现卡片库呢？</li>
</ol>
<p>我们先来解决卡片顺序的问题。SwiftUI 提供 <code>zIndex</code>修饰器，来指示 ZStack 中的视图顺序。zIndex 值较高的视图，位于较低值的视图之上，因此最上面的卡片应该有最大的 <code>zIndex</code> 值。</p>
<p>考虑到这一点，我们先在 <code>ContentView</code> 中建立以下的新函数：</p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">isTopCard</span><span class="hljs-params">(cardView: CardView)</span> -&gt; <span class="hljs-title">Bool</span> </span>{

    guard <span class="hljs-keyword">let</span> index = cardViews.firstIndex(<span class="hljs-keyword">where</span>: { $<span class="hljs-number">0</span>.id == cardView.id }) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
    }

    <span class="hljs-keyword">return</span> index == <span class="hljs-number">0</span>
}
</code></pre>
<p>在逐一执行卡片视图时，我们必须找到一种识别最上面卡片的方式。上面的函式带入一个卡片视图，找出其索引，并告诉你卡片视图是否位于最上面。</p>
<p>接下来，更新 <code>ZStack</code> 的代码区块如下： </p>
<pre><code class="lang-swift"><span class="hljs-type">ZStack</span> {
    <span class="hljs-type">ForEach</span>(cardViews) { cardView <span class="hljs-keyword">in</span>
        cardView
            .zIndex(<span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
    }
}
</code></pre>
<p>我们为每个卡片视图加入了 <code>zIndex</code> 修饰器。对于最上面的卡片，我们为其指定较高的 <code>zIndex</code> 值。在预览画布中，你现在应该会看到第一个旅程的照片（即美国优胜美地国家公园）。</p>
<p>对于第二个问题，则更复杂些，我们的目标是确保卡片库可支持数以万计的卡片视图， 而不需耗费大量资源。</p>
<p>我们来更深入研究一下卡片库。我们是否真的需要为每张旅程照片初始化个别的卡片视图呢？要建立这个卡片库UI，我们只需建立两个卡片视图，并将它们互相重叠即可。</p>
<p>当最上面的卡片视图被丢弃时，下面的卡片视图将成为最上面的卡片；同时，我们立即使用不同的照片初始化一个新的卡片视图，并将它放在最上面的卡片后面。无论你需要在卡片库中显示多少张照片，App 永远只有两个卡片视图。不过，从使用者的角度来看，UI 是由一堆卡片所组成。</p>
<figure id="fig19.9"><img src="images/triptinder/swiftui-trip-tinder-11.jpg" alt="图 19.9.　我们如何使用两个卡片视图来建立卡片库"><figcaption>图 19.9.　我们如何使用两个卡片视图来建立卡片库</figcaption></figure>
<p>现在，你应该了解我们如何建立卡片库，我们来继续进行实现。</p>
<p>首先，更新 <code>cardViews</code> 数组，我们不再需要初始化所有的旅程，而只需要初始化前两个旅程。之后，当第一个旅程（即第一张卡片）被丢弃时，我们会加入另一张卡片。</p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> cardViews: [<span class="hljs-type">CardView</span>] = {

    <span class="hljs-keyword">var</span> views = [<span class="hljs-type">CardView</span>]()

    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">2</span> {
        views.append(<span class="hljs-type">CardView</span>(image: trips[index].image, title: trips[index].destination))
    }

    <span class="hljs-keyword">return</span> views
}()
</code></pre>
<p>更改代码之后，UI 看起来应该完全相同。但在底层架构中，你应该在卡片库中只看到两个卡片视图。</p>
<h3 id="%E5%AF%A6%E4%BD%9C%E6%BB%91%E5%8B%95%E5%8B%95%E4%BD%9C">实现滑动动作</h3>
<p>在动态建立新的卡片视图之前，我们必须先实现滑动功能。如果你忘记湍如何处理手势，请再阅读第17 章及第18 章。我们将会重新使用前面讨论的一些代码。</p>
<p>首先，在 <code>ContentView</code> 中定义 <code>DragState</code>枚举，它表示可能的拖曳状态： </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DragState</span> </span>{
    <span class="hljs-keyword">case</span> inactive
    <span class="hljs-keyword">case</span> pressing
    <span class="hljs-keyword">case</span> dragging(translation: <span class="hljs-type">CGSize</span>)

    <span class="hljs-keyword">var</span> translation: <span class="hljs-type">CGSize</span> {
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
        <span class="hljs-keyword">case</span> .inactive, .pressing:
            <span class="hljs-keyword">return</span> .zero
        <span class="hljs-keyword">case</span> .dragging(<span class="hljs-keyword">let</span> translation):
            <span class="hljs-keyword">return</span> translation
        }
    }

    <span class="hljs-keyword">var</span> isDragging: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
        <span class="hljs-keyword">case</span> .dragging:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>
        <span class="hljs-keyword">case</span> .pressing, .inactive:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
        }
    }

    <span class="hljs-keyword">var</span> isPressing: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
        <span class="hljs-keyword">case</span> .pressing, .dragging:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>
        <span class="hljs-keyword">case</span> .inactive:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
        }
    }

}
</code></pre>
<p>再一次，如果你不了解什么是枚举，则请在此处停止，并复习一下有关手势的章节。接下来，我们定义一个<code>@GestureState</code> 变量来储存拖曳状态，预设上设定为“inactive”： </p>
<pre><code class="lang-swift">@<span class="hljs-type">GestureState</span> private <span class="hljs-keyword">var</span> dragState = <span class="hljs-type">DragState</span>.inactive
</code></pre>
<p>现在，更新 <code>body</code> 的部分如下： </p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    <span class="hljs-type">VStack</span> {
        <span class="hljs-type">TopBarMenu</span>()

        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">ForEach</span>(cardViews) { cardView <span class="hljs-keyword">in</span>
                cardView
                    .zIndex(<span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
                    .offset(x: <span class="hljs-keyword">self</span>.dragState.translation.width, y:  <span class="hljs-keyword">self</span>.dragState.translation.height)
                    .scaleEffect(<span class="hljs-keyword">self</span>.dragState.isDragging ? <span class="hljs-number">0.95</span> : <span class="hljs-number">1.0</span>)
                    .rotationEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-type">Double</span>( <span class="hljs-keyword">self</span>.dragState.translation.width / <span class="hljs-number">10</span>)))
                    .animation(.interpolatingSpring(stiffness: <span class="hljs-number">180</span>, damping: <span class="hljs-number">100</span>), value: <span class="hljs-keyword">self</span>.dragState.translation)
                    .gesture(<span class="hljs-type">LongPressGesture</span>(minimumDuration: <span class="hljs-number">0.01</span>)
                        .sequenced(before: <span class="hljs-type">DragGesture</span>())
                        .updating(<span class="hljs-keyword">self</span>.$dragState, body: { (value, state, transaction) <span class="hljs-keyword">in</span>
                            <span class="hljs-keyword">switch</span> value {
                            <span class="hljs-keyword">case</span> .first(<span class="hljs-built_in">true</span>):
                                state = .pressing
                            <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag):
                                state = .dragging(translation: drag?.translation ?? .zero)
                            <span class="hljs-keyword">default</span>:
                                <span class="hljs-keyword">break</span>
                            }

                        })

                    )
            }
        }

        <span class="hljs-type">Spacer</span>(minLength: <span class="hljs-number">20</span>)

        <span class="hljs-type">BottomBarMenu</span>()
            .opacity(dragState.isDragging ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>)
            .animation(.<span class="hljs-keyword">default</span>, value: dragState.isDragging)
    }
}
</code></pre>
<p>基本上，我们将应用在手势章节中所学的知识来实现拖曳。<code>.gesture</code> 修饰器有两个手势识别器：长按与拖曳。当侦测到拖曳手势时，我们更新 <code>dragState</code> 变量，并储存拖曳的位移量。</p>
<p><code>offset</code>、<code>scaleEffect</code>、<code>rotationEffect</code> 与 <code>animation</code> 修饰器的结合， 可建立拖曳效果。拖曳是透过更新卡片视图的 <code>offset</code>来实现。当卡片视图处于拖曳状态时，我们会使用 <code>scaleEffect</code> 将它缩小一点，并应用<code>rotationEffect</code> 修饰器将它旋转特定角度。动画设定为 <code>interpolatingSpring</code>，但你可以自由尝试其他动画。</p>
<p>我们还对 <code>BottomBarMenu</code> 做一些代码更改。当使用者拖曳卡片视图时，我想要隐藏底部列，因此我们应用 <code>.opacity</code> 修饰器，并且当它在拖曳状态时，设定它的值为“0”。</p>
<p>进行更改后，在预览画布中执行项目来测试它。你应该能够拖曳卡片并四处移动。而当你释放卡片时，卡片会回到原来的位置，如图 19.10 所示。</p>
<figure id="fig19.10"><img src="images/triptinder/swiftui-trip-tinder-13.png" alt="图 19.10.　拖曳卡片视图"><figcaption>图 19.10.　拖曳卡片视图</figcaption></figure>
<p>你注意到问题了吗？当拖曳开始时，你实际上是在拖曳整个卡片库 ！假设使用者只能拖曳最上面的卡片，下面的卡片应该保持不变。而且，缩放效果应只应用于最上面的卡片。</p>
<p>要解决这些问题，我们需要修改 <code>offset</code>、<code>scaleEffect</code> 与 <code>rotationEffect</code> 修饰器的代码， 如此拖曳只发生在最上面的卡片视图。</p>
<pre><code class="lang-swift"><span class="hljs-type">ZStack</span> {
    <span class="hljs-type">ForEach</span>(cardViews) { cardView <span class="hljs-keyword">in</span>
        cardView
            .zIndex(<span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
            .offset(x: <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-keyword">self</span>.dragState.translation.width : <span class="hljs-number">0</span>, y: <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-keyword">self</span>.dragState.translation.height : <span class="hljs-number">0</span>)
            .scaleEffect(<span class="hljs-keyword">self</span>.dragState.isDragging &amp;&amp; <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">0.95</span> : <span class="hljs-number">1.0</span>)
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-type">Double</span>( <span class="hljs-keyword">self</span>.dragState.translation.width / <span class="hljs-number">10</span>) : <span class="hljs-number">0</span>))
            .animation(.interpolatingSpring(stiffness: <span class="hljs-number">180</span>, damping: <span class="hljs-number">100</span>), value: <span class="hljs-keyword">self</span>.dragState.translation)
            .gesture(<span class="hljs-type">LongPressGesture</span>(minimumDuration: <span class="hljs-number">0.01</span>)
                .sequenced(before: <span class="hljs-type">DragGesture</span>())
                .updating(<span class="hljs-keyword">self</span>.$dragState, body: { (value, state, transaction) <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">switch</span> value {
                    <span class="hljs-keyword">case</span> .first(<span class="hljs-built_in">true</span>):
                        state = .pressing
                    <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag):
                        state = .dragging(translation: drag?.translation ?? .zero)
                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">break</span>
                    }

                })

            )
    }
}
</code></pre>
<p>只需要对 <code>offse</code>、<code>scaleEffect</code> 与 <code>rotationEffect</code> 修饰器进行修改，其余的代码保持不变。对于那些修饰器，我们进行额外的检查，以使效果只应用在最上面的卡片。</p>
<p>现在，如果你再次执 行 App，则应该看到其下方的卡片，并只能拖曳最上面的卡片。</p>
<figure id="fig19.11"><img src="images/triptinder/swiftui-trip-tinder-14.png" alt="图 19.11.　拖曳效果只应用在最上面的卡片"><figcaption>图 19.11.　拖曳效果只应用在最上面的卡片</figcaption></figure>
<h3 id="%E9%A1%AF%E7%A4%BA%E5%BF%83%E5%BD%A2%E8%88%87-%C3%97-%E5%BD%A2%E5%9C%96%E7%A4%BA">显示心形与 &#xD7; 形图示</h3>
<p>酷 ！拖曳现在可以运作了，不过它还没有完成。使用者应该能够向右/ 向左滑动，来丢弃最上面的卡片。而且，根据滑动的方向，卡片上应该显示一个图示（心形或 &#xD7; 形）。</p>
<p>首先，我们在 <code>ContentView</code> 中声明一个拖曳的界限值： </p>
<pre><code class="lang-swift">private <span class="hljs-keyword">let</span> dragThreshold: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">80.0</span>
</code></pre>
<p>当拖曳的位移超过界限值时，我们将在卡片上重叠一个图示（心形或&#xD7; 形）。另外， 如果使用者释放卡片，App 会从卡片库中删除这张卡片，并建立一张新卡片，将其放置于卡片库的末尾。</p>
<p>要重叠图示，加入一个 <code>overlay</code> 修饰器至 <code>cardViews</code>。你可以在 <code>.zIndex</code> 修饰器下插入下列的代码： </p>
<pre><code class="lang-swift">.overlay {
    <span class="hljs-type">ZStack</span> {
        <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;x.circle&quot;</span>)
            .foregroundColor(.white)
            .font(.system(size: <span class="hljs-number">100</span>))
            .opacity(<span class="hljs-keyword">self</span>.dragState.translation.width &lt; -<span class="hljs-keyword">self</span>.dragThreshold &amp;&amp; <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0</span>)

        <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;heart.circle&quot;</span>)
            .foregroundColor(.white)
            .font(.system(size: <span class="hljs-number">100</span>))
            .opacity(<span class="hljs-keyword">self</span>.dragState.translation.width &gt; <span class="hljs-keyword">self</span>.dragThreshold  &amp;&amp; <span class="hljs-keyword">self</span>.isTopCard(cardView: cardView) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>)
    }
}
</code></pre>
<p>预设上，将不透明度设定为“0”来隐藏这两张图片。如果向右拖曳，则位移的宽度为正值，否则其为负值。依照拖曳的方向，当拖曳的位移超过界限值时，App 将显示其中一张图片。</p>
<p>你可以执行这个项目来快速测试一下。当你的拖曳超出界限值时，心形/&#xD7; 形图示将会出现，如图 19.12 所示。</p>
<figure id="fig19.12"><img src="images/triptinder/swiftui-trip-tinder-15.png" alt="图 19.12.　出现心形图示"><figcaption>图 19.12.　出现心形图示</figcaption></figure>
<h3 id="%E5%88%AA%E9%99%A4-%E6%8F%92%E5%85%A5%E5%8D%A1%E7%89%87">删除/ 插入卡片</h3>
<p>现在，当你释放卡片时，它仍会回到原来的位置。我们如何才能删除最上面的卡片， 并同时加入一张新卡片呢？ </p>
<p>首先，我们使用 <code>@State</code> 来标记 <code>cardViews</code> 数组，以让我们可以更新它的值，并重新更新 UI： </p>
<pre><code class="lang-swift">@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> cardViews: [<span class="hljs-type">CardView</span>] = {

    <span class="hljs-keyword">var</span> views = [<span class="hljs-type">CardView</span>]()

    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">2</span> {
        views.append(<span class="hljs-type">CardView</span>(image: trips[index].image, title: trips[index].destination))
    }

    <span class="hljs-keyword">return</span> views
}()
</code></pre>
<p>接下来，声明另一个状态变量来追踪旅程的最后一个索引。假设卡片库第一次初始化时，我们显示储存在 <code>trips</code> 数组中的前两个旅程，最后一个索引设定为 <code>1</code>。</p>
<pre><code class="lang-swift">@<span class="hljs-type">State</span> private <span class="hljs-keyword">var</span> lastIndex = <span class="hljs-number">1</span>
</code></pre>
<p>下面是用于删除及插入卡片视图的核心函数。定义一个名为 <code>moveCard</code> 新函数： </p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">moveCard</span><span class="hljs-params">()</span> </span>{
    cardViews.removeFirst()

    <span class="hljs-keyword">self</span>.lastIndex += <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> trip = trips[lastIndex % trips.<span class="hljs-built_in">count</span>]

    <span class="hljs-keyword">let</span> newCardView = <span class="hljs-type">CardView</span>(image: trip.image, title: trip.destination)

    cardViews.append(newCardView)
}
</code></pre>
<p>这个函式先从 <code>cardViews</code> 数组中删除最上面的卡片，然后它使用后续旅程的图片来实例化一个新卡片视图。由于 <code>cardViews</code> 定义为状态属性，因此一旦数组的值更改时，SwiftUI 将再次渲染卡片视图，这就是我们如何删除最上面的卡片，并插入一张新卡片至卡片库的方式。</p>
<p>针对这个范例，我想要卡片库继续显示一个旅程。在 <code>trips</code> 数组的最后一张图片显示后， App 将会回到第一个元素（注意，上列代码中的模数运算子%）。</p>
<p>接下来，更新 <code>.gesture</code>修饰器，并插入 <code>.onEnded</code> 函式： </p>
<pre><code class="lang-swift">.gesture(<span class="hljs-type">LongPressGesture</span>(minimumDuration: <span class="hljs-number">0.01</span>)
    .sequenced(before: <span class="hljs-type">DragGesture</span>())
    .updating(<span class="hljs-keyword">self</span>.$dragState, body: { (value, state, transaction) <span class="hljs-keyword">in</span>
        .
        .
        .
    })
    .onEnded({ (value) <span class="hljs-keyword">in</span>

        guard <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag?) = value <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> drag.translation.width &lt; -<span class="hljs-keyword">self</span>.dragThreshold ||
            drag.translation.width &gt; <span class="hljs-keyword">self</span>.dragThreshold {

            <span class="hljs-keyword">self</span>.moveCard()
        }
    })
)
</code></pre>
<p>当拖曳手势结束时，我们检查拖曳的位移是否超过界限值，并相应调用 <code>moveCard()</code>。</p>
<p>现在，当你在预览画布中执行项目时，将图片向右 / 左拖曳，直到图示出现。放开拖曳，最上面的卡片应由下一张卡片取代。</p>
<figure id="fig19.13"><img src="images/triptinder/swiftui-trip-tinder-16.png" alt="图 19.13.　删除最上面的图片"><figcaption>图 19.13.　删除最上面的图片</figcaption></figure>
<h3 id="%E5%BE%AE%E8%AA%BF%E5%8B%95%E7%95%AB">微调动画</h3>
<p>这个 App 几乎可以运作了，但是动画效果并不如预期。不要让卡片视图突然消失，而是卡片丢弃后应逐渐从荧幕离开。</p>
<p>要微调动画效果，我们将加上 <code>transition</code> 修饰器，并应用不对称转场至卡片视图。</p>
<p>现在建立一个 <code>AnyTransition</code> 扩展（可以加在 <code>ContentView.swift</code>最后端），并定义两个转场效果：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> trailingBottom: <span class="hljs-type">AnyTransition</span> {
        <span class="hljs-type">AnyTransition</span>.asymmetric(
            insertion: .identity,
            removal: <span class="hljs-type">AnyTransition</span>.move(edge: .trailing).combined(with: .move(edge: .bottom))
        )

    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> leadingBottom: <span class="hljs-type">AnyTransition</span> {
        <span class="hljs-type">AnyTransition</span>.asymmetric(
            insertion: .identity,
            removal: <span class="hljs-type">AnyTransition</span>.move(edge: .leading).combined(with: .move(edge: .bottom))
        )
    }
}
</code></pre>
<p>之所以使用不对称转场，是因为我们只想在卡片视图被删除时，对转场设定动画。当一个新卡片视图插入卡片库时，则不应有动画。</p>
<p>当卡片视图向荧幕右方丢弃时，使用 <code>trailingBottom</code> 转场，而当卡片视图向荧幕左方丢弃时，则使用<code>leadingBottom</code> 转场。</p>
<p>接下来，声明一个包含转场类型的状态属性，预设是设定 <code>trailingBottom</code>。</p>
<pre><code class="lang-swift">@<span class="hljs-type">State</span> private <span class="hljs-keyword">var</span> removalTransition = <span class="hljs-type">AnyTransition</span>.trailingBottom
</code></pre>
<p>现在，将 <code>.transition</code> 修饰器加到卡片视图。你可以将它放在 <code>.animation</code> 修饰器之后： </p>
<pre><code class="lang-swift">.transition(<span class="hljs-keyword">self</span>.removalTransition)
</code></pre>
<p>最后，使用 <code>onChanged</code> 函式更新 <code>.gesture</code> 修饰器的代码，如下所示： </p>
<pre><code class="lang-swift">.gesture(<span class="hljs-type">LongPressGesture</span>(minimumDuration: <span class="hljs-number">0.01</span>)
    .sequenced(before: <span class="hljs-type">DragGesture</span>())
    .updating(<span class="hljs-keyword">self</span>.$dragState, body: { (value, state, transaction) <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">switch</span> value {
        <span class="hljs-keyword">case</span> .first(<span class="hljs-built_in">true</span>):
            state = .pressing
        <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag):
            state = .dragging(translation: drag?.translation ?? .zero)
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>
        }

    })
    .onChanged({ (value) <span class="hljs-keyword">in</span>
        guard <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag?) = value <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> drag.translation.width &lt; -<span class="hljs-keyword">self</span>.dragThreshold {
            <span class="hljs-keyword">self</span>.removalTransition = .leadingBottom
        }

        <span class="hljs-keyword">if</span> drag.translation.width &gt; <span class="hljs-keyword">self</span>.dragThreshold {
            <span class="hljs-keyword">self</span>.removalTransition = .trailingBottom
        }

    })
    .onEnded({ (value) <span class="hljs-keyword">in</span>

        guard <span class="hljs-keyword">case</span> .second(<span class="hljs-built_in">true</span>, <span class="hljs-keyword">let</span> drag?) = value <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> drag.translation.width &lt; -<span class="hljs-keyword">self</span>.dragThreshold ||
            drag.translation.width &gt; <span class="hljs-keyword">self</span>.dragThreshold {

            <span class="hljs-keyword">self</span>.moveCard()
        }
    })

)
</code></pre>
<p>上列代码的作用是设定 <code>removalTransition</code>，转场类型是根据滑动方向来更新。现在，你可以再次执行 App 了，当丢弃卡片时，你应该会看到动画效果已改善。</p>
<h3 id="%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%B5%90">本章小结</h3>
<p>使用 SwiftUI，你可以轻松建立一些很酷的动画与行动装置 UI 模式，这个如 Tinder 般的 UI 就是一个例子。</p>
<p>我希望你能真正了解本章所介绍的内容，如此你就可以修改代码，来配合自己的项目。这是非常重要的一章，我想要记录一下我的思考过程，而不仅仅是向你提供最终的解决方案。</p>
<p>为了方便进一步参考，您可以至下列网址下载完整项目： </p>
<ul>
<li>范例项目 (<a href="https://www.appcoda.com/resources/swiftui4/SwiftUITinderTrip.zip" target="_blank">https://www.appcoda.com/resources/swiftui4/SwiftUITinderTrip.zip</a>) 。</li>
</ul>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./swiftui-bottom-sheet.html" class="navigation navigation-prev " aria-label="Previous page: 以SwiftUI 手势与 GeometryReader 建立一个底部展开式页面"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./swiftui-advanced-animations.html" class="navigation navigation-next " aria-label="Next page: 建立像 Apple Wallet App 的动画和转场效果"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":"white","family":"serif","size":3},"image-captions":{"caption":"_CAPTION_","variable_name":"_pictures"}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
