<!DOCTYPE HTML>
<html lang="zh-tw" >
    
    <head>
        
        <meta charset=utf-8"UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=11; IE=10; IE=9; IE=8; IE=7; IE=EDGE" />
        <title>把所学应用出来！构建个人理财App | 精通 SwiftUI - iOS 16 版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.0.1">
        <meta name="author" content="Simon Ng">
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    <link rel="next" href="./swiftui-appstoreanimation.html" />
    
    
    <link rel="prev" href="./swiftui-searchbar.html" />
    

        
    </head>
    <body>
        
        
    <link rel="stylesheet" href="gitbook/style.css">
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-image-captions/image-captions.css">
        
    
    
        <link rel="stylesheet" href="././styles/website.css">
    

        
    <div class="book" data-level="25" data-basepath="." data-revision="Thu Dec 01 2022 17:36:55 GMT+0800 (HKT)">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="输入并搜寻" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
            
            <li>
                <a href="https://www.appcoda.com.tw" target="blank" class="custom-link">Made by AppCoda</a>
            </li>
        
            
            <li>
                <a href="https://www.appcoda.com.tw/contact" target="blank" class="custom-link">Contact us / Support</a>
            </li>
        
            
            <li>
                <a href="http://twitter.com/share?text=Mastering%20SwiftUI%20via%20@appcodamobile&amp;url=https://www.appcoda.com.tw/swiftui/&amp;hashtags=swiftlang" target="blank" class="custom-link">Tweet this book</a>
            </li>
        
        

        
        <li class="divider"></li>
        

        
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                        <i class="fa fa-check"></i>
                        
                        序言
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="swiftui-basics.html">
            
                
                    <a href="./swiftui-basics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        SwiftUI 介绍
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="swiftui-text.html">
            
                
                    <a href="./swiftui-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        SwiftUI 入门 - 文字的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="swiftui-images.html">
            
                
                    <a href="./swiftui-images.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        图片的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="4" data-path="swiftui-stacks.html">
            
                
                    <a href="./swiftui-stacks.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        以堆叠布局使用者介面
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="5" data-path="swiftui-scrollview.html">
            
                
                    <a href="./swiftui-scrollview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        ScrollView 与 Carousel UI 的建立
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="6" data-path="swiftui-buttons.html">
            
                
                    <a href="./swiftui-buttons.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                        SwiftUI 按钮与渐层
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="7" data-path="swiftui-state.html">
            
                
                    <a href="./swiftui-state.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                        状态(State)与绑定(Binding)
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="8" data-path="swiftui-path-shape.html">
            
                
                    <a href="./swiftui-path-shape.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                        实现路径(Path)与形状(Shape)来画线与圆饼图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="9" data-path="swiftui-animation.html">
            
                
                    <a href="./swiftui-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                        基础动画与转场
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="10" data-path="swiftui-list.html">
            
                
                    <a href="./swiftui-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                        动态列表、 ForEach 与 Identifiable 的使用方法
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="11" data-path="swiftui-navigation.html">
            
                
                    <a href="./swiftui-navigation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                        导览UI与导览列客制化运用
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="12" data-path="swiftui-modal.html">
            
                
                    <a href="./swiftui-modal.html">
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                        强制回应视图、浮动按钮与提示的实现
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="13" data-path="swiftui-form.html">
            
                
                    <a href="./swiftui-form.html">
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                        以选取器(Picker)、开关(Toggle)与步进器(Stepper)来建立一个表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="14" data-path="swiftui-form-data.html">
            
                
                    <a href="./swiftui-form-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                        使用 Combine 与 Environment 物件进行资料分享
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="15" data-path="swiftui-form-registration.html">
            
                
                    <a href="./swiftui-form-registration.html">
                        <i class="fa fa-check"></i>
                        
                            <b>15.</b>
                        
                        以 Combine 与 视图模型建立一个注册表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="16" data-path="swiftui-actionsheet-context.html">
            
                
                    <a href="./swiftui-actionsheet-context.html">
                        <i class="fa fa-check"></i>
                        
                            <b>16.</b>
                        
                        滑动删除、内容选单与动作列表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="17" data-path="swiftui-gestures.html">
            
                
                    <a href="./swiftui-gestures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>17.</b>
                        
                        认识手势（Gestures）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="18" data-path="swiftui-bottom-sheet.html">
            
                
                    <a href="./swiftui-bottom-sheet.html">
                        <i class="fa fa-check"></i>
                        
                            <b>18.</b>
                        
                        以SwiftUI 手势与 GeometryReader 建立一个底部展开式页面
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="19" data-path="swiftui-trip-tinder.html">
            
                
                    <a href="./swiftui-trip-tinder.html">
                        <i class="fa fa-check"></i>
                        
                            <b>19.</b>
                        
                        使用手势与动画建立 Tinder 风格的 UI
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="20" data-path="swiftui-advanced-animations.html">
            
                
                    <a href="./swiftui-advanced-animations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>20.</b>
                        
                        建立像 Apple Wallet App 的动画和转场效果
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="21" data-path="swiftui-json.html">
            
                
                    <a href="./swiftui-json.html">
                        <i class="fa fa-check"></i>
                        
                            <b>21.</b>
                        
                        JSON、滑杆的运用与资料过滤
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="22" data-path="swiftui-core-data.html">
            
                
                    <a href="./swiftui-core-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>22.</b>
                        
                        如何使用 Core Data 建立 ToDo App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="23" data-path="swiftui-uikit.html">
            
                
                    <a href="./swiftui-uikit.html">
                        <i class="fa fa-check"></i>
                        
                            <b>23.</b>
                        
                        利用 UIViewRepresentable 整合UIKit 组件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="24" data-path="swiftui-searchbar.html">
            
                
                    <a href="./swiftui-searchbar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>24.</b>
                        
                        建立搜寻栏视图并使用自订绑定（Custom Binding）
                    </a>
                
            
            
        </li>
    
        <li class="chapter active" data-level="25" data-path="swiftui-real-world-app.html">
            
                
                    <a href="./swiftui-real-world-app.html">
                        <i class="fa fa-check"></i>
                        
                            <b>25.</b>
                        
                        把所学应用出来！构建个人理财App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="26" data-path="swiftui-appstoreanimation.html">
            
                
                    <a href="./swiftui-appstoreanimation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>26.</b>
                        
                        创建类似App Store使用的动画视图转换
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="27" data-path="swiftui-carousel.html">
            
                
                    <a href="./swiftui-carousel.html">
                        <i class="fa fa-check"></i>
                        
                            <b>27.</b>
                        
                        如何建立图像轮播（Image Carousel）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="28" data-path="swiftui-expandable-list.html">
            
                
                    <a href="./swiftui-expandable-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>28.</b>
                        
                        如何建立展开式列表视图和大纲视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="29" data-path="swiftui-gridlayout.html">
            
                
                    <a href="./swiftui-gridlayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>29.</b>
                        
                        使用 LazyVGrid 和 LazyHGrid 构建集合视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="30" data-path="swiftui-progress-ring.html">
            
                
                    <a href="./swiftui-progress-ring.html">
                        <i class="fa fa-check"></i>
                        
                            <b>30.</b>
                        
                        使用 Shape 和 Animatable 开发带动画的环形进度条
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="31" data-path="swiftui-library.html">
            
                
                    <a href="./swiftui-library.html">
                        <i class="fa fa-check"></i>
                        
                            <b>31.</b>
                        
                        如何使用 AnimatableModifier 和 LibraryContentProvider
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="32" data-path="swiftui-texteditor.html">
            
                
                    <a href="./swiftui-texteditor.html">
                        <i class="fa fa-check"></i>
                        
                            <b>32.</b>
                        
                        使用 TextEditor 支持多行文字输入
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="33" data-path="swiftui-matchedgeometry.html">
            
                
                    <a href="./swiftui-matchedgeometry.html">
                        <i class="fa fa-check"></i>
                        
                            <b>33.</b>
                        
                        使用 matchedGeometryEffect为 App 建立绚丽的视图动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="34" data-path="swiftui-grid-animation.html">
            
                
                    <a href="./swiftui-grid-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>34.</b>
                        
                        ScrollViewReader 和网格动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="35" data-path="swiftui-tabview.html">
            
                
                    <a href="./swiftui-tabview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>35.</b>
                        
                        标签视图的运用与自订标签列
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="36" data-path="swiftui-asyncimage.html">
            
                
                    <a href="./swiftui-asyncimage.html">
                        <i class="fa fa-check"></i>
                        
                            <b>36.</b>
                        
                        利用 AsyncImage 非同步加载和显示图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="37" data-path="swiftui-searchable.html">
            
                
                    <a href="./swiftui-searchable.html">
                        <i class="fa fa-check"></i>
                        
                            <b>37.</b>
                        
                        利用 Searchable 建立搜寻栏
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="38" data-path="swiftui-charts.html">
            
                
                    <a href="./swiftui-charts.html">
                        <i class="fa fa-check"></i>
                        
                            <b>38.</b>
                        
                        利用 Charts 框架建立图表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="39" data-path="swiftui-live-text.html">
            
                
                    <a href="./swiftui-live-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>39.</b>
                        
                        利用 Live Text API 从图片中撷取文本
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="40" data-path="swiftui-sharelink.html">
            
                
                    <a href="./swiftui-sharelink.html">
                        <i class="fa fa-check"></i>
                        
                            <b>40.</b>
                        
                        通过 ShareLink 来分享文本和图像等资料
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="41" data-path="swiftui-imagerenderer.html">
            
                
                    <a href="./swiftui-imagerenderer.html">
                        <i class="fa fa-check"></i>
                        
                            <b>41.</b>
                        
                        利用 ImageRenderer API 轻松把 SwiftUI 视图转换为图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="42" data-path="swiftui-pdf-doc.html">
            
                
                    <a href="./swiftui-pdf-doc.html">
                        <i class="fa fa-check"></i>
                        
                            <b>42.</b>
                        
                        如何把 SwiftUI 视图转换为 PDF 文件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="43" data-path="swiftui-gauge.html">
            
                
                    <a href="./swiftui-gauge.html">
                        <i class="fa fa-check"></i>
                        
                            <b>43.</b>
                        
                        使用 Gauge 视图显示进度并创建速度计
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="44" data-path="swiftui-grid.html">
            
                
                    <a href="./swiftui-grid.html">
                        <i class="fa fa-check"></i>
                        
                            <b>44.</b>
                        
                        使用Grid API 创建网格布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="45" data-path="swiftui-anylayout.html">
            
                
                    <a href="./swiftui-anylayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>45.</b>
                        
                        利用 AnyLayout 切换 UI 布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="46" data-path="swiftui-navigationstack.html">
            
                
                    <a href="./swiftui-navigationstack.html">
                        <i class="fa fa-check"></i>
                        
                            <b>46.</b>
                        
                        使用新的 NavigationStack 视图构建资料导向的导航
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                本书使用 GitBook 释出
            </a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="目录"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="搜寻"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="字型设定"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">衬线体</button>
        <button type="button" data-font="1" class="button">无衬线体</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">白色</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">棕褐色</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">夜间</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="分享"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">
                    分享到 Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    分享到 Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    分享到 Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    分享到 Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    分享到 Instapaper
                </button>
            </div>
        </div>
    </div>
    

    
    
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >精通 SwiftUI - iOS 16 版</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="%E7%AC%AC-25-%E7%AB%A0-br-%E6%8A%8A%E6%89%80%E5%AD%B8%E6%87%89%E7%94%A8%E5%87%BA%E4%BE%86%EF%BC%81%E6%A7%8B%E5%BB%BA%E5%80%8B%E4%BA%BA%E7%90%86%E8%B2%A1app">第 25 章<br>把所学应用出来！构建个人理财App</h1>
<p>到目前为止，您应该已经对 SwiftUI 有了很好的了解，并且已经能使用这个新框架构建了一些简单的App。 在本章中，您应用所学的技巧来开发一只个人理财App，让使用者可以记录自己的收入和支出。</p>
<figure id="fig25.1"><img src="images/real-world-app/real-world-app-1.png" alt="图 25.1. 个人理财App"><figcaption>图 25.1. 个人理财App</figcaption></figure>
<p>这个App构建起来并不太复杂，但你会学到很多关于 SwiftUI 的知识，并了解如何应用你所学的技术。 简而言之，以下是我们会建立的功能和将会讲解的内容：</p>
<ol>
<li>如何构建表格并验证使用者输入</li>
<li>如何过滤记录和更新列表视图</li>
<li>如何使用底页（Bottom Sheet）显示记录详情</li>
<li>如何在 SwiftUI 中使用 MVVM（Model- View-ViewModel 的缩写）</li>
<li>如何利用 Core Data 储存和管理数据库的数据</li>
<li>如何使用 DatePicker 给使用者选择日期</li>
<li>如何处理键盘通知和调整表单位置</li>
</ol>
<p>让我再次强调这一点。 这个App是你将所学应用出来的成果。 因此，我假设你已经阅读了第 1 章到第 24 章。你应该了解如何构建Bottom Sheet（第 18 章）、使用 Combine 验证表单（第 14 章和第 15 章）以及如何使用 Core Data（第 22 章）。 如果您还没有阅读这些章节，我建议您先阅读它们。 在本章中，我将集中讲解以前没有讨论过的技术。</p>
<h3 id="%E4%B8%8B%E8%BC%89%E5%AE%8C%E6%95%B4%E5%B0%88%E6%A1%88">下载完整项目</h3>
<p>一般来说，我们是从头开始构建一个示例App。 这一次有点不同。 我已经写好了这个个人理财App。 您可以从 <a href="https://www.appcoda.com/resources/swiftui4/SwiftUIPFinance.zip" target="_blank">https://www.appcoda.com/resources/swiftui4/SwiftUIPFinance.zip</a> 下载完整代码。 解压档案并在模拟器上试试运行App。 当App第一次启动时，它看起来与图 25.1 所示的有点不同，因为没有记录。 您可以点击 + 按钮添加新记录。 返回主视图后，您可在 <em>Recent Transactions</em> 部分看到新记录。 并且，App 会自动计算总余额。</p>
<p>此App 使用 Core Data 执行数据管理。 收入和支出记录存放在内置数据库中，因此即使在重新启动App后，您也会看到记录。</p>
<p>在本章的其余部分，我将详细解释内里的代码是如何运作的。 但我鼓励你试试自己先看一下代码，看看你能了解多少。</p>
<h3 id="%E4%BA%86%E8%A7%A3%E6%A8%A1%E5%9E%8B">了解模型</h3>
<p>正如您在项目导航器中看到的，App分为三个主要部分：模型（Model）、视图模型（ViewModel）和视图（View）。 让我们从模型层和Core Data模型开始。 打开 <code>PaymentActivity.swift</code> 看一下：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PaymentCategory</span>: <span class="hljs-title">Int</span> </span>{
    <span class="hljs-keyword">case</span> income = <span class="hljs-number">0</span>
    <span class="hljs-keyword">case</span> expense = <span class="hljs-number">1</span>
}

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentActivity</span>: <span class="hljs-title">NSManagedObject</span> </span>{

    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> paymentId: <span class="hljs-type">UUID</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> date: <span class="hljs-type">Date</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> address: <span class="hljs-type">String</span>?
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> amount: <span class="hljs-type">Double</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> memo: <span class="hljs-type">String</span>?
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> typeNum: <span class="hljs-type">Int32</span>
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">PaymentActivity</span>: <span class="hljs-title">Identifiable</span> </span>{
    <span class="hljs-keyword">var</span> type: <span class="hljs-type">PaymentCategory</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-type">PaymentCategory</span>(rawValue: <span class="hljs-type">Int</span>(typeNum)) ?? .expense
        }

        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.typeNum = <span class="hljs-type">Int32</span>(newValue.rawValue)
        }
    }
}
</code></pre>
<p><code>PaymentActivity</code> 类别代表支出或收入的付款记录。 在上面的代码，我们使用 Enum 来区分支付类型。 每笔付款都具有以下属性：</p>
<ul>
<li><strong>paymentId</strong> - 交易记录的 ID</li>
<li><strong>date</strong> -交易日期</li>
<li><strong>name</strong> - 交易名称</li>
<li><strong>address</strong> - 你在那里消费/收入来自那里</li>
<li><strong>amount</strong> - 交易金额</li>
<li><strong>memo</strong> - 交易的附加说明</li>
<li><strong>typeNum</strong> - 交易类型（收入/费用）</li>
</ul>
<p>由于我们使用 Core Data 来永久记录交易数据，所以这个 <code>PaymentActivity</code> 类别继承 <code>NSManagedObject</code>。 稍后，您将在 Core Data 模型中看到，该类别被设置为客制化的托管物件（Managed Object）。 再说一次，如果您不了解 Core Data，请参阅第 22 章。</p>
<p>交易类型（即 <code>typeNum</code>）在数据库中是以整数存放的。 因此，我们需要在整数和Enum之间进行转换。 这是将Enum存放在数据库中的一种方法。</p>
<p>最后，我们采用了 <code>Identifiable</code>协议。 为什么我们需要使用它？ 我们将使用<code>List</code>视图来展示所有交易活动。 这就是 <code>PaymentActivity</code> 类别采用该协议的原因。 如果你忘记了 <code>Identifiable</code> 协议是什么，你可以重读第 10 章。</p>
<h3 id="%E4%BD%BF%E7%94%A8-core-data">使用 Core Data</h3>
<p>现在，打开<code>PFinanceStore</code>查看托管数据模型（managed data model）。 在模型中，我们只有一个实体 <em>PaymentActivity</em>。</p>
<figure id="fig25.2"><img src="images/real-world-app/real-world-app-2.png" alt="图 25.2. PaymentActivity 实体"><figcaption>图 25.2. PaymentActivity 实体</figcaption></figure>
<p>正如我们之前讨论的，<code>PaymentActivity</code>类别就是用来配数据模型里这个<em>PaymentActivity</em>实体。 您可以单击数据模型检查器以显示设置。 如前所述，我更喜欢手动自订类别（而不是 codegen），所以 Class 里的 Codegen 选项是设为“Manual/None”。 这使我可以更灵活地自订类别。</p>
<p>接下来，让我们前往 <code>Persistence.swift</code>（在 <em>Model</em> 组内）看看这个数据模型是如何加载的。 在 <code>PersistenceController</code> 结构中，您应该看到以下代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PersistenceController</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">PersistenceController</span>()

    <span class="hljs-keyword">let</span> container: <span class="hljs-type">NSPersistentContainer</span>

    .
    .
    .

    <span class="hljs-keyword">init</span>(inMemory: <span class="hljs-type">Bool</span> = <span class="hljs-built_in">false</span>) {
        container = <span class="hljs-type">NSPersistentContainer</span>(name: <span class="hljs-string">&quot;PFinanceStore&quot;</span>)
        <span class="hljs-keyword">if</span> inMemory {
            container.persistentStoreDescriptions.first!.url = <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-string">&quot;/dev/null&quot;</span>)
        }
        container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>? {
                fatalError(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(error)</span>, <span class="hljs-subst">\(error.userInfo)</span>&quot;</span>)
            }
        })
    }
}
</code></pre>
<p>当App启动时，我们使用 <code>NSPersistentContainer</code> 加载 <code>PFinanceStore.xcdatamodeld</code>。 现在，切换到 <code>PFinanceApp.swift</code> 并看看代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PFinanceApp</span>: <span class="hljs-title">App</span> </span>{

    <span class="hljs-keyword">let</span> persistenceController = <span class="hljs-type">PersistenceController</span>.shared

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">DashboardView</span>().environment(\.managedObjectContext, persistenceController.container.viewContext)
        }
    }
}
</code></pre>
<p>在 SwiftUI 中使用 Core Data 的技巧是将托管物件内容（managed object context）注入到环境中。 稍后，在 SwiftUI 视图中，我们可以轻松地从环境中读取 context 以进行下一步的操作。</p>
<h3 id="%E5%AF%A6%E4%BD%9C-new-payment-view">实现 New Payment View</h3>
<p>相信你已对模型层有一定了解，现在让我们看看如何实现每个视图。 <em>New Payment</em> 视图专为使用者建立新的交易（收入或支出）而设计。 打开 <code>PaymentFormView.swift</code> 看看， 您应该能够预览输入表单。</p>
<figure id="fig25.3"><img src="images/real-world-app/real-world-app-3.png" alt="图 25.3. Payment Form 视图"><figcaption>图 25.3. Payment Form 视图</figcaption></figure>
<h4 id="form-%E7%9A%84%E4%BD%88%E5%B1%80">Form 的布局</h4>
<p>让我先向您介绍表单的布局方式。 当开发 SwiftUI 介面时，时刻都要记着将一些常用的视图变得可以轻易重用。 由于大多数表单的文字栏都非常相似，我创建了一个通用的文本栏（即 <code>FormTextField</code>）：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FormTextField</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> placeHolder: <span class="hljs-type">String</span>

    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">String</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>(alignment: .leading) {
            <span class="hljs-type">Text</span>(name.uppercased())
                .font(.system(.subheadline, design: .rounded))
                .fontWeight(.bold)
                .foregroundColor(.primary)

            <span class="hljs-type">TextField</span>(placeHolder, text: $value)
                .font(.headline)
                .foregroundColor(.primary)
                .padding()
                .border(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;Border&quot;</span>), width: <span class="hljs-number">1.0</span>)

        }
    }
}
</code></pre>
<p>您是否注意到表单标题下的两个验证错误？ 由于这些验证讯息的格式相似，我们就为此类讯息建立了一个独立视图：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ValidationErrorText</span>: <span class="hljs-title">View</span> </span>{

    <span class="hljs-keyword">var</span> iconName = <span class="hljs-string">&quot;info.circle&quot;</span>
    <span class="hljs-keyword">var</span> iconColor = <span class="hljs-type">Color</span>(red: <span class="hljs-number">251</span>/<span class="hljs-number">255</span>, green: <span class="hljs-number">128</span>/<span class="hljs-number">255</span>, blue: <span class="hljs-number">128</span>/<span class="hljs-number">255</span>)

    <span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;&quot;</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">HStack</span> {
            <span class="hljs-type">Image</span>(systemName: iconName)
                .foregroundColor(iconColor)
            <span class="hljs-type">Text</span>(text)
                .font(.system(.body, design: .rounded))
                .foregroundColor(.secondary)
            <span class="hljs-type">Spacer</span>()
        }
    }
}
</code></pre>
<p>建立了这两个通用视图后，建立表格就变得非常简单。 我们使用 <code>ScrollView</code> 和 <code>VStack</code> 来排列表格栏。 只有在检测到错误时才会显示错误讯息：</p>
<pre><code class="lang-swift"><span class="hljs-type">Group</span> {
    <span class="hljs-keyword">if</span> !paymentFormViewModel.isNameValid {
        <span class="hljs-type">ValidationErrorText</span>(text: <span class="hljs-string">&quot;Please enter the payment name&quot;</span>)
    }

    <span class="hljs-keyword">if</span> !paymentFormViewModel.isAmountValid {
        <span class="hljs-type">ValidationErrorText</span>(text: <span class="hljs-string">&quot;Please enter a valid amount&quot;</span>)
    }

    <span class="hljs-keyword">if</span> !paymentFormViewModel.isMemoValid {
        <span class="hljs-type">ValidationErrorText</span>(text: <span class="hljs-string">&quot;Your memo should not exceed 300 characters&quot;</span>)
    }
}
</code></pre>
<p><em>type</em> 字栏有点不同，因为它不属于文字栏。 使用者可以选择<em>收入</em>或<em>费用</em>。 在本例中，我们建立了两个按钮：</p>
<pre><code class="lang-swift"><span class="hljs-type">VStack</span>(alignment: .leading) {
    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;TYPE&quot;</span>)
        .font(.system(.subheadline, design: .rounded))
        .fontWeight(.bold)
        .foregroundColor(.primary)
        .padding(.vertical, <span class="hljs-number">10</span>)

    <span class="hljs-type">HStack</span>(spacing: <span class="hljs-number">0</span>) {
        <span class="hljs-type">Button</span>(action: {
            <span class="hljs-keyword">self</span>.paymentFormViewModel.type = .income
        }) {
            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Income&quot;</span>)
                .font(.headline)
                .foregroundColor(<span class="hljs-keyword">self</span>.paymentFormViewModel.type == .income ? <span class="hljs-type">Color</span>.white : <span class="hljs-type">Color</span>.primary)
        }
        .frame(minWidth: <span class="hljs-number">0.0</span>, maxWidth: .infinity)
        .padding()
        .background(<span class="hljs-keyword">self</span>.paymentFormViewModel.type == .income ? <span class="hljs-type">Color</span>(<span class="hljs-string">&quot;IncomeCard&quot;</span>) : <span class="hljs-type">Color</span>.white)

        <span class="hljs-type">Button</span>(action: {
            <span class="hljs-keyword">self</span>.paymentFormViewModel.type = .expense
        }) {
            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Expense&quot;</span>)
                .font(.headline)
                .foregroundColor(<span class="hljs-keyword">self</span>.paymentFormViewModel.type == .expense ? <span class="hljs-type">Color</span>.white : <span class="hljs-type">Color</span>.primary)
        }
        .frame(minWidth: <span class="hljs-number">0.0</span>, maxWidth: .infinity)
        .padding()
        .background(<span class="hljs-keyword">self</span>.paymentFormViewModel.type == .expense ? <span class="hljs-type">Color</span>(<span class="hljs-string">&quot;ExpenseCard&quot;</span>) : <span class="hljs-type">Color</span>.white)
    }
    .border(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;Border&quot;</span>), width: <span class="hljs-number">1.0</span>)
}
</code></pre>
<p>按钮的背景颜色因交易活动的类型而改变。</p>
<p>日期栏是使用 <code>DatePicker</code> 组件实现的。 要使用 <code>DatePicker</code> 非常容易， 您只需要提供标签、与日期值的绑定以及<code>displayedComponents</code>参数。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FormDateField</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>

    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Date</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>(alignment: .leading) {
            <span class="hljs-type">Text</span>(name.uppercased())
                .font(.system(.subheadline, design: .rounded))
                .fontWeight(.bold)
                .foregroundColor(.primary)

            <span class="hljs-type">DatePicker</span>(<span class="hljs-string">&quot;&quot;</span>, selection: $value, displayedComponents: .date)
                .accentColor(.primary)
                .padding(<span class="hljs-number">10</span>)
                .border(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;Border&quot;</span>), width: <span class="hljs-number">1.0</span>)
                .labelsHidden()
        }
    }
}
</code></pre>
<p>在 iOS 14 （或以上版本），内置的 <code>DatePicker</code>改进了不少。新版本提供了更好的 UI 和更多样式。 如果您运行视图并点击日期字段，App会显示完整的日历视图供使用者选择日期。 UI 比旧版本的日期选择器要好得多。</p>
<figure id="fig25.4"><img src="images/real-world-app/real-world-app-4.png" alt="图 25.4. 点击日期选项会显示完整的日历"><figcaption>图 25.4. 点击日期选项会显示完整的日历</figcaption></figure>
<p><em>memo</em> 栏也不属文字栏，而是文字编辑器。 在 iOS 13 （或更旧版本），SwiftUI 没有提供多行文字输入的组件。 要支持多行文字编辑的话，您需要整合 UIKit 框架并将 <code>UITextView</code> 包装到 SwiftUI 组件中。 从 iOS 14 开始，Swift 引入了一个名为<code>TextEditor</code>的新组件，用于显示和编辑长文字。 在 <code>PaymentFormView.swift</code> 中，您应该找到以下结构：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FormTextEditor</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">80.0</span>

    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">String</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>(alignment: .leading) {
            <span class="hljs-type">Text</span>(name.uppercased())
                .font(.system(.subheadline, design: .rounded))
                .fontWeight(.bold)
                .foregroundColor(.primary)

            <span class="hljs-type">TextEditor</span>(text: $value)
                .frame(minHeight: height)
                .font(.headline)
                .foregroundColor(.primary)
                .padding()
                .border(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;Border&quot;</span>), width: <span class="hljs-number">1.0</span>)
        }
    }
}
</code></pre>
<p><code>TextEditor</code> 的用法与<code>TextField</code> 非常相似。 您只需将 String 变量绑定传递给<code>TextEditor</code>即可。 就像任何其他 SwiftUI 视图一样，您可以应用视图修饰器来设置其外观样式。 </p>
<p>在表格的最后，就是 <em>Save</em> 按钮。 在预设的情况下，此按钮是不能用的。 使用者要填写所有必填表格栏时，这个 <em>Save</em> 按钮才可使用。 <code>disabled</code> 修饰器就是用于控制按钮的状态：</p>
<pre><code class="lang-swift"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-keyword">self</span>.save()
    <span class="hljs-keyword">self</span>.presentationMode.wrappedValue.dismiss()
}) {
    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Save&quot;</span>)
        .opacity(paymentFormViewModel.isFormInputValid ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.5</span>)
        .font(.headline)
        .foregroundColor(.white)
        .padding()
        .frame(minWidth: <span class="hljs-number">0</span>, maxWidth: .infinity)
        .background(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;IncomeCard&quot;</span>))
        .cornerRadius(<span class="hljs-number">10</span>)

}
.padding()
.disabled(!paymentFormViewModel.isFormInputValid)
</code></pre>
<p>当点击按钮时，App会调用<code>save()</code>方法将交易永久存放到数据库中。 然后，就调用 <code>dismiss()</code> 方法来关闭视图。 如果您不熟悉环境值 <code>presentationMode</code>，请阅读第 12 章。</p>
<h4 id="%E8%A1%A8%E6%A0%BC%E9%A9%97%E8%AD%89">表格验证</h4>
<p>这就是布局表格 UI 的技巧，现在让我们来谈谈表格验证。 基本上，我是按照第 15 章中讨论的内容，使用 Combine 执行表格验证：</p>
<ol>
<li>建立一个视图模型（view model）来代表交易活动表格（payment activity form）。</li>
<li>在视图模型中验证表格输入并使用 Combine 发布验证结果。</li>
</ol>
<p>我们创建了一个视图模型类别（view model class）来储存表格栏的值。 你可以切换到<code>PaymentFormViewModel.swift</code>查看代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentFormViewModel</span>: <span class="hljs-title">ObservableObject</span> </span>{

    <span class="hljs-comment">// Input</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> location = <span class="hljs-string">&quot;&quot;</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> amount = <span class="hljs-string">&quot;&quot;</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> type = <span class="hljs-type">PaymentCategory</span>.expense
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> date = <span class="hljs-type">Date</span>.today
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> memo = <span class="hljs-string">&quot;&quot;</span>

    <span class="hljs-comment">// Output</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isNameValid = <span class="hljs-built_in">false</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isAmountValid = <span class="hljs-built_in">true</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isMemoValid = <span class="hljs-built_in">true</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isFormInputValid = <span class="hljs-built_in">false</span>

    private <span class="hljs-keyword">var</span> cancellableSet: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">AnyCancellable</span>&gt; = []

    <span class="hljs-keyword">init</span>(paymentActivity: <span class="hljs-type">PaymentActivity</span>?) {

        <span class="hljs-keyword">self</span>.name = paymentActivity?.name ?? <span class="hljs-string">&quot;&quot;</span>
        <span class="hljs-keyword">self</span>.location = paymentActivity?.address ?? <span class="hljs-string">&quot;&quot;</span>
        <span class="hljs-keyword">self</span>.amount = <span class="hljs-string">&quot;<span class="hljs-subst">\(paymentActivity?.amount ?? <span class="hljs-number">0.0</span>)</span>&quot;</span>
        <span class="hljs-keyword">self</span>.memo = paymentActivity?.memo ?? <span class="hljs-string">&quot;&quot;</span>
        <span class="hljs-keyword">self</span>.type = paymentActivity?.type ?? .expense
        <span class="hljs-keyword">self</span>.date = paymentActivity?.date ?? <span class="hljs-type">Date</span>.today

        $name
            .receive(on: <span class="hljs-type">RunLoop</span>.main)
            .<span class="hljs-built_in">map</span> { name <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">return</span> name.<span class="hljs-built_in">count</span> &gt; <span class="hljs-number">0</span>
            }
            .assign(to: \.isNameValid, on: <span class="hljs-keyword">self</span>)
            .store(<span class="hljs-keyword">in</span>: &amp;cancellableSet)

        $amount
            .receive(on: <span class="hljs-type">RunLoop</span>.main)
            .<span class="hljs-built_in">map</span> { amount <span class="hljs-keyword">in</span>
                guard <span class="hljs-keyword">let</span> validAmount = <span class="hljs-type">Double</span>(amount) <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
                }
                <span class="hljs-keyword">return</span> validAmount &gt; <span class="hljs-number">0</span>
            }
            .assign(to: \.isAmountValid, on: <span class="hljs-keyword">self</span>)
            .store(<span class="hljs-keyword">in</span>: &amp;cancellableSet)

        $memo
            .receive(on: <span class="hljs-type">RunLoop</span>.main)
            .<span class="hljs-built_in">map</span> { memo <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">return</span> memo.<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">300</span>
            }
            .assign(to: \.isMemoValid, on: <span class="hljs-keyword">self</span>)
            .store(<span class="hljs-keyword">in</span>: &amp;cancellableSet)

        <span class="hljs-type">Publishers</span>.<span class="hljs-type">CombineLatest3</span>($isNameValid, $isAmountValid, $isMemoValid)
            .receive(on: <span class="hljs-type">RunLoop</span>.main)
            .<span class="hljs-built_in">map</span> { (isNameValid, isAmountValid, isMemoValid) <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">return</span> isNameValid &amp;&amp; isAmountValid &amp;&amp; isMemoValid
            }
            .assign(to: \.isFormInputValid, on: <span class="hljs-keyword">self</span>)
            .store(<span class="hljs-keyword">in</span>: &amp;cancellableSet)
    }

}
</code></pre>
<p>这个类别遵守<code>ObservableObject</code>。 所有属性都以<code>@Published</code>标注，因为我们想在数值发生变化时通知订阅者并相应地执行验证。</p>
<p>每当使用者输入表格栏时，此视图模型就会执行验证代码并更新结果，以及通知订阅者。</p>
<p>那么，谁是订阅者？</p>
<p>如果你回到 <code>PaymentFormView.swift</code>，你应该注意到我们已经用 <code>@ObservedObject</code> 标注了一个名为 <code>paymentFormViewModel</code> 的变量：</p>
<pre><code class="lang-swift">@<span class="hljs-type">ObservedObject</span> private <span class="hljs-keyword">var</span> paymentFormViewModel: <span class="hljs-type">PaymentFormViewModel</span>
</code></pre>
<p><code>PaymentFormView</code> 会侦测视图模型的变化。 当任何验证变量（例如 <code>isNameValid</code>）更新时，<code>PaymentFormView</code> 就会收到通知，视图相应地显示验证错误。</p>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> !paymentFormViewModel.isNameValid {
    <span class="hljs-type">ValidationErrorText</span>(text: <span class="hljs-string">&quot;Please enter the payment name&quot;</span>)
}
</code></pre>
<h4 id="%E8%A1%A8%E6%A0%BC%E5%88%9D%E5%A7%8B%E5%8C%96">表格初始化</h4>
<p>你有没有注意到<code>init</code>方法？ 它接受一个<code>PaymentActivity</code>物件并初始化视图模型。</p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> payment: <span class="hljs-type">PaymentActivity</span>?

<span class="hljs-keyword">init</span>(payment: <span class="hljs-type">PaymentActivity</span>? = <span class="hljs-built_in">nil</span>) {
    <span class="hljs-keyword">self</span>.payment = payment
    <span class="hljs-keyword">self</span>.paymentFormViewModel = <span class="hljs-type">PaymentFormViewModel</span>(paymentActivity: payment)
}
</code></pre>
<p><code>PaymentFormView</code> 允许使用者建立新的交易并编辑现有交易记录。 这就是为什么 init 方法需要接受一个可选择性的支付物件。 如果物件是 <code>nil</code>，我们将显示一个空表格。 否则，我们用 <code>PaymentActivity</code> 物件填充表格栏的值。</p>
<h4 id="%E9%A0%90%E8%A6%BD%E8%A1%A8%E6%A0%BC">预览表格</h4>
<p>即时预览功能是 SwiftUI 其中一个最受欢迎的功能。 但是，如果要与 Core Data 整合，则需要一些额外的代码才能使预览成功运作。 这是预览的代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PaymentFormView_Previews</span>: <span class="hljs-title">PreviewProvider</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {

        <span class="hljs-keyword">let</span> context = <span class="hljs-type">PersistenceController</span>.shared.container.viewContext

        <span class="hljs-keyword">let</span> testTrans = <span class="hljs-type">PaymentActivity</span>(context: context)
        testTrans.paymentId = <span class="hljs-type">UUID</span>()
        testTrans.name = <span class="hljs-string">&quot;&quot;</span>
        testTrans.amount = <span class="hljs-number">0.0</span>
        testTrans.date = .today
        testTrans.type = .expense

        <span class="hljs-keyword">return</span> <span class="hljs-type">Group</span> {
            <span class="hljs-type">PaymentFormView</span>(payment: testTrans)
            <span class="hljs-type">PaymentFormView</span>(payment: testTrans)
                .preferredColorScheme(.dark)
                .previewDisplayName(<span class="hljs-string">&quot;Payment Form View (Dark)&quot;</span>)

            <span class="hljs-type">FormTextField</span>(name: <span class="hljs-string">&quot;NAME&quot;</span>, placeHolder: <span class="hljs-string">&quot;Enter your payment&quot;</span>, value: .constant(<span class="hljs-string">&quot;&quot;</span>)).previewLayout(.sizeThatFits)
                .previewDisplayName(<span class="hljs-string">&quot;Form Text Field&quot;</span>)

            <span class="hljs-type">ValidationErrorText</span>(text: <span class="hljs-string">&quot;Please enter the payment name&quot;</span>).previewLayout(.sizeThatFits)
                .previewDisplayName(<span class="hljs-string">&quot;Validation Error&quot;</span>)

        }
    }
}
</code></pre>
<p>要使用<code>PaymentFormView</code>，您必须提供一个<code>PaymentActivity</code>物件。 由于<code>PaymentActivity</code>是一个托管物件（managed object），我们需要从<code>PersistenceController</code>中读取<code>context</code>来创建一个。 一旦我们创建了 <code>PaymentActivity</code> 物件，就可以用它来预览 <code>PaymentFormView</code>。</p>
<h3 id="%E5%AF%A6%E4%BD%9C%E4%BA%A4%E6%98%93%E6%B4%BB%E5%8B%95%E8%A9%B3%E7%B4%B0%E8%A6%96%E5%9C%96">实现交易活动详细视图</h3>
<p>现在让我们讨论下一个视图并看看交易活动详细视图是如何实现的。 当使用者在 <em>Recent Transactions</em> 中选择一项交易活动时，此视图就会弹出来。 它显示交易的详细信息，例如数额和消费地点。 您可以打开 <code>PaymentDetailView.swift</code> 来查看 UI 的外观， 这样您会更了解详细视图。</p>
<figure id="fig25.5"><img src="images/real-world-app/real-world-app-5.png" alt="图 25.5. 交易活动详细视图"><figcaption>图 25.5. 交易活动详细视图</figcaption></figure>
<h4 id="%E4%BD%BF%E7%94%A8%E8%80%85%E4%BB%8B%E9%9D%A2">使用者介面</h4>
<p>详细视图非常简单。 相信你都知道如何布局组件，我就不逐行解释代码了。 要留意是以下的代码：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> payment: <span class="hljs-type">PaymentActivity</span>

private <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">PaymentDetailViewModel</span>

<span class="hljs-keyword">init</span>(payment: <span class="hljs-type">PaymentActivity</span>) {

    <span class="hljs-keyword">self</span>.payment = payment
    <span class="hljs-keyword">self</span>.viewModel = <span class="hljs-type">PaymentDetailViewModel</span>(payment: payment)
}
</code></pre>
<p>由于我们需要执行一些初始化来创建视图模型，我们加了一个客制化的 <code>init</code> 方法。</p>
<h4 id="%E8%A6%96%E5%9C%96%E6%A8%A1%E5%9E%8B%EF%BC%88view-model%EF%BC%89">视图模型（View Model）</h4>
<blockquote>
<p>我们可以把视图分成视图及其视图模型等两个组件，而不是将所有的东西放在一个视图中。视图本身是负责 UI 布局，而视图模型存放要在视图中显示的状态与资料，并且视图模型还处理资料验证与转换。对于有经验的开发者而言，你知道我们正应用众所周知的“MVVM”（Model- View-ViewModel 的缩写）设计模式。</p>
<p>- 摘自第 15 章</p>
</blockquote>
<p>为了将实际的视图数据与视图 UI 分开，我们建立了一个名为<code>PaymentDetailViewModel</code>的视图模型：</p>
<pre><code class="lang-swift">private <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">PaymentDetailViewModel</span>
</code></pre>
<p>为什么我们需要创建一个额外的视图模型来存放视图的数据？ 看看标题 <em>Payment Details</em> 旁边的图标。 这是一个动态图标，会随着支付/交易类型而变化。 另外，你注意到金额的格式吗？ App的一项要求是金额仅可显示两个小数位。当然， 我们可以在视图中处理这个格式问题，但是如果您不断在视图中加入这些逻辑处理，视图将变得过于复杂变得越来越难维护。</p>
<p>计算机程式设计有一个原则叫做“单一职责”原则（single responsibility principle）。它指出程式中的每个类别或模块都应该只负责一个功能。 SRP （single responsibility principle的缩写）是编写好代码的关键之一，让您的代码更易于维护和阅读。</p>
<p>这就是我们将视图分为两个组件的原因：</p>
<ol>
<li><code>PaymentDetailView</code> 只负责UI布局。</li>
<li><code>PaymentDetailViewModel</code> 则负责将视图的数据转换为预定的显示格式。</li>
</ol>
<p>打开 <code>PaymentDetailViewModel</code> 看看：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PaymentDetailViewModel</span> </span>{

    <span class="hljs-keyword">var</span> payment: <span class="hljs-type">PaymentActivity</span>

    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> payment.name
    }

    <span class="hljs-keyword">var</span> date: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> payment.date.string()
    }

    <span class="hljs-keyword">var</span> address: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> payment.address ?? <span class="hljs-string">&quot;&quot;</span>
    }

    <span class="hljs-keyword">var</span> typeIcon: <span class="hljs-type">String</span> {

        <span class="hljs-keyword">let</span> icon: <span class="hljs-type">String</span>

        <span class="hljs-keyword">switch</span> payment.type {
        <span class="hljs-keyword">case</span> .income: icon = <span class="hljs-string">&quot;arrowtriangle.up.circle.fill&quot;</span>
        <span class="hljs-keyword">case</span> .expense: icon = <span class="hljs-string">&quot;arrowtriangle.down.circle.fill&quot;</span>
        }

        <span class="hljs-keyword">return</span> icon
    }

    <span class="hljs-keyword">var</span> image: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;payment-detail&quot;</span>

    <span class="hljs-keyword">var</span> amount: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">let</span> formatter = <span class="hljs-type">NumberFormatter</span>()
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = <span class="hljs-number">2</span>

        <span class="hljs-keyword">let</span> formattedValue = formatter.string(from: <span class="hljs-type">NSNumber</span>(value: payment.amount)) ?? <span class="hljs-string">&quot;&quot;</span>

        <span class="hljs-keyword">let</span> formattedAmount = ((payment.type == .income) ? <span class="hljs-string">&quot;+&quot;</span> : <span class="hljs-string">&quot;-&quot;</span>) + <span class="hljs-string">&quot;$&quot;</span> + formattedValue

        <span class="hljs-keyword">return</span> formattedAmount
    }

    <span class="hljs-keyword">var</span> memo: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> payment.memo ?? <span class="hljs-string">&quot;&quot;</span>
    }

    <span class="hljs-keyword">init</span>(payment: <span class="hljs-type">PaymentActivity</span>) {
        <span class="hljs-keyword">self</span>.payment = payment
    }

}
</code></pre>
<p>如您所见，我们在此视图模型（view model）中加入所有转换逻辑。 我们可以把这些逻辑放回视图（view）中吗？ 当然可以。 但是，我相信将视图分成两部分（view 和 view model）会使代码更清楚。</p>
<h3 id="%E5%84%80%E8%A1%A8%E6%9D%BF%E8%A6%96%E5%9C%96">仪表板视图</h3>
<p>现在是时候和你讲解仪表板视图了。 在个人理财App的所有视图中，这个视图是最复杂的。</p>
<figure id="fig25.6"><img src="images/real-world-app/real-world-app-6.png" alt="图 25.6. 仪表板视图"><figcaption>图 25.6. 仪表板视图</figcaption></figure>
<h4 id="%E8%8F%9C%E5%96%AE%E6%AC%84%EF%BC%88menu-bar%EF%BC%89">菜单栏（Menu Bar）</h4>
<p>打开 <code>Dashboard.swift</code>，让我们从菜单栏开始：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuBar</span>&lt;<span class="hljs-title">Content</span>&gt;: <span class="hljs-title">View</span> <span class="hljs-title">where</span> <span class="hljs-title">Content</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> private <span class="hljs-keyword">var</span> showPaymentForm = <span class="hljs-built_in">false</span>

    <span class="hljs-keyword">let</span> modalContent: () -&gt; <span class="hljs-type">Content</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span>(alignment: .trailing) {
            <span class="hljs-type">HStack</span>(alignment: .center) {
                <span class="hljs-type">Spacer</span>()

                <span class="hljs-type">VStack</span>(alignment: .center) {
                    <span class="hljs-type">Text</span>(<span class="hljs-type">Date</span>.today.string(with: <span class="hljs-string">&quot;EEEE, MMM d, yyyy&quot;</span>))
                        .font(.caption)
                        .foregroundColor(.gray)
                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Personal Finance&quot;</span>)
                        .font(.title)
                        .fontWeight(.black)
                }

                <span class="hljs-type">Spacer</span>()
            }

            <span class="hljs-type">Button</span>(action: {
                <span class="hljs-keyword">self</span>.showPaymentForm = <span class="hljs-built_in">true</span>
            }) {
                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;plus.circle&quot;</span>)
                    .font(.title)
                    .foregroundColor(.primary)
            }

            .sheet(isPresented: <span class="hljs-keyword">self</span>.$showPaymentForm, onDismiss: {
                <span class="hljs-keyword">self</span>.showPaymentForm = <span class="hljs-built_in">false</span>
            }) {
                <span class="hljs-keyword">self</span>.modalContent()
            }
        }

    }
}
</code></pre>
<p>菜单栏的布局很简单。 它显示App的标题、今天的日期和＋按钮。 此菜单栏视图能够接受任何强制回应视图（即<code>modalContent</code>）。 点击 + 按钮时，将显示模态视图。 如果你不知道如何在 SwiftUI 中创建通用视图，可以参考第 17 章。</p>
<h4 id="%E6%94%B6%E5%85%A5%E3%80%81%E6%94%AF%E5%87%BA%E5%92%8C%E7%B8%BD%E9%A4%98%E9%A1%8D">收入、支出和总余额</h4>
<p>接下来，我们利用三个卡片视图来显示总余额、收入和支出。 这是收入卡视图的代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IncomeCard</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> income = <span class="hljs-number">0.0</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {

        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Rectangle</span>()
                .foregroundColor(<span class="hljs-type">Color</span>(<span class="hljs-string">&quot;IncomeCard&quot;</span>))
                .cornerRadius(<span class="hljs-number">15.0</span>)

            <span class="hljs-type">VStack</span> {
                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Income&quot;</span>)
                    .font(.system(.title, design: .rounded))
                    .fontWeight(.black)
                    .foregroundColor(.white)
                <span class="hljs-type">Text</span>(<span class="hljs-type">NumberFormatter</span>.currency(from: income))
                    .font(.system(.title, design: .rounded))
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .minimumScaleFactor(<span class="hljs-number">0.1</span>)
            }
        }
        .frame(height: <span class="hljs-number">150</span>)

    }
}
</code></pre>
<p>我们只需使用 <code>ZStack</code> 将文字覆盖在彩色矩形上。 利用类似的技巧，我们就可布局 <code>TotalBalanceCard</code> 和 <code>ExpenseCard</code>。 那么，我们如何计算收入、支出和总余额呢？ 我们在 <code>DashboardView</code> 的开头声明了三个计算属性：</p>
<pre><code class="lang-swift">private <span class="hljs-keyword">var</span> totalIncome: <span class="hljs-type">Double</span> {
    <span class="hljs-keyword">let</span> total = paymentActivities
        .<span class="hljs-built_in">filter</span> {
            $<span class="hljs-number">0</span>.type == .income
        }.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>) {
            $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span>.amount
        }

    <span class="hljs-keyword">return</span> total
}

private <span class="hljs-keyword">var</span> totalExpense: <span class="hljs-type">Double</span> {
    <span class="hljs-keyword">let</span> total = paymentActivities
        .<span class="hljs-built_in">filter</span> {
            $<span class="hljs-number">0</span>.type == .expense
        }.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>) {
            $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span>.amount
        }

    <span class="hljs-keyword">return</span> total
}

private <span class="hljs-keyword">var</span> totalBalance: <span class="hljs-type">Double</span> {
    <span class="hljs-keyword">return</span> totalIncome - totalExpense
}
</code></pre>
<p><code>paymentActivities</code> 变量存放了所有交易活动。要计算总收入的话，我们首先使用 <code>filter</code> 函数过滤那些交易为 <code>.income</code> ，然后使用 <code>reduce</code> 函数计算总收入。 只要使用相同的技巧就可计算出总支出。 Swift 的高阶函数非常好用。 如果您不知道如何使用 filter 和 reduce，您可以读一读这篇教学文（<a href="https://www.appcoda. com/higher-order-functions-swift/" target="_blank">https://www.appcoda.com/higher-order-functions-swift/</a>)。</p>
<h4 id="%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%A4%E6%98%93">最近的交易</h4>
<p>UI 的最后一部分是最近交易的列表。 由于所有行的布局都一样（支付类型的图标除外），我们为交易行创建一个通用视图，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransactionCellView</span>: <span class="hljs-title">View</span> </span>{

    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> transaction: <span class="hljs-type">PaymentActivity</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {

        <span class="hljs-type">HStack</span>(spacing: <span class="hljs-number">20</span>) {

            <span class="hljs-keyword">if</span> transaction.isFault {
                <span class="hljs-type">EmptyView</span>()

            }  <span class="hljs-keyword">else</span> {

                <span class="hljs-type">Image</span>(systemName: transaction.type == .income ? <span class="hljs-string">&quot;arrowtriangle.up.circle.fill&quot;</span> : <span class="hljs-string">&quot;arrowtriangle.down.circle.fill&quot;</span>)
                    .font(.title)
                    .foregroundColor(<span class="hljs-type">Color</span>(transaction.type == .income ? <span class="hljs-string">&quot;IncomeCard&quot;</span> : <span class="hljs-string">&quot;ExpenseCard&quot;</span>))

                <span class="hljs-type">VStack</span>(alignment: .leading) {
                    <span class="hljs-type">Text</span>(transaction.name)
                        .font(.system(.body, design: .rounded))
                    <span class="hljs-type">Text</span>(transaction.date.string())
                        .font(.system(.caption, design: .rounded))
                        .foregroundColor(.gray)
                }

                <span class="hljs-type">Spacer</span>()

                <span class="hljs-type">Text</span>((transaction.type == .income ? <span class="hljs-string">&quot;+&quot;</span> : <span class="hljs-string">&quot;-&quot;</span>) + <span class="hljs-type">NumberFormatter</span>.currency(from: transaction.amount))
                    .font(.system(.headline, design: .rounded))
            }
        }
        .padding(.vertical, <span class="hljs-number">5</span>)

    }
}
</code></pre>
<p>这个cell视图接受一个<code>PaymentActivity</code>物件以显示它的内容。 为了确保托管物件（即交易）有效，我们会读取<code>isFault</code>属性先检查一下。</p>
<p>为了显示所有交易，我们使用<code>ForEach</code>将每一个交易活动创建一个<code>TransactionCellView</code>：</p>
<pre><code class="lang-swift"><span class="hljs-type">ForEach</span>(paymentDataForView) { transaction <span class="hljs-keyword">in</span>
    <span class="hljs-type">TransactionCellView</span>(transaction: transaction)
        .onTapGesture {
            <span class="hljs-keyword">self</span>.showPaymentDetails = <span class="hljs-built_in">true</span>
            <span class="hljs-keyword">self</span>.selectedPaymentActivity = transaction
        }
        .contextMenu {
            <span class="hljs-type">Button</span>(action: {
                <span class="hljs-comment">// Edit payment details</span>
                <span class="hljs-keyword">self</span>.editPaymentDetails = <span class="hljs-built_in">true</span>
                <span class="hljs-keyword">self</span>.selectedPaymentActivity = transaction

            }) {
                <span class="hljs-type">HStack</span> {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Edit&quot;</span>)
                    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;pencil&quot;</span>)
                }
            }

            <span class="hljs-type">Button</span>(action: {
                <span class="hljs-comment">// Delete the selected payment</span>
                <span class="hljs-keyword">self</span>.delete(payment: transaction)
            }) {
                <span class="hljs-type">HStack</span> {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Delete&quot;</span>)
                    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;trash&quot;</span>)
                }
            }
        }
}
.sheet(isPresented: <span class="hljs-keyword">self</span>.$editPaymentDetails) {
    <span class="hljs-type">PaymentFormView</span>(payment: <span class="hljs-keyword">self</span>.selectedPaymentActivity).environment(\.managedObjectContext, <span class="hljs-keyword">self</span>.context)
}
</code></pre>
<p>当使用者按住其中一行时，它会显示一个包含删除和编辑选项的内容选单（Context Menu）。 选择编辑选项时，App将使用所选的交易创建<code>PaymentFormView</code>。 对于删除动作，我们通过 Core Data 从数据库中完全删除交易记录。</p>
<figure id="fig25.7"><img src="images/real-world-app/real-world-app-7.png" alt="图 25.7. 内容选单"><figcaption>图 25.7. 内容选单</figcaption></figure>
<p>不知你没有注意到 <code>paymentDataForView</code> 变量？ 列表视图并没有使用 <code>paymentActivities</code>，而是显示存放在 <code>paymentDataForView</code> 中的项目。 为什么是这样？</p>
<p>在 <em>Recent Transactions</em> 部分，App为使用者提供了三个选项来过滤交易活动，包括全部（All）、收入（Income）和支出（Expense）。 例如，如果选择了 <em>expense</em> 选项，就仅显示与与支出相关的交易。</p>
<pre><code class="lang-swift">private <span class="hljs-keyword">var</span> paymentDataForView: [<span class="hljs-type">PaymentActivity</span>] {

    <span class="hljs-keyword">switch</span> listType {
    <span class="hljs-keyword">case</span> .all:
        <span class="hljs-keyword">return</span> paymentActivities
            .sorted(by: { $<span class="hljs-number">0</span>.date.compare($<span class="hljs-number">1</span>.date) == .orderedDescending })
    <span class="hljs-keyword">case</span> .income:
        <span class="hljs-keyword">return</span> paymentActivities
            .<span class="hljs-built_in">filter</span> { $<span class="hljs-number">0</span>.type == .income }
            .sorted(by: { $<span class="hljs-number">0</span>.date.compare($<span class="hljs-number">1</span>.date) == .orderedDescending })
    <span class="hljs-keyword">case</span> .expense:
        <span class="hljs-keyword">return</span> paymentActivities
            .<span class="hljs-built_in">filter</span> { $<span class="hljs-number">0</span>.type == .expense }
            .sorted(by: { $<span class="hljs-number">0</span>.date.compare($<span class="hljs-number">1</span>.date) == .orderedDescending })
    }
}
</code></pre>
<p><code>paymentDataForView</code> 是另一个计算属性，它传回一个交易活动集合。 在代码中，我们使用<code>filter</code>函数来过滤交易活动，并使用<code>sort</code>函数将交易活动排序。</p>
<h4 id="%E5%BA%95%E9%A0%81%EF%BC%88the-bottom-sheet%EF%BC%89">底页（The Bottom Sheet）</h4>
<p>交易详细信息视图是以<code>BottomSheet</code>形式显示。 当使用者点击交易记录时，bottom sheet 会从荧幕底部弹出来并显示支付详情。 另外，bottom sheet 是可以扩展至全荧幕的，使用者可以向上拖动详细视图就可以展开它。 相反地，使用者可以向下拖动视图将其关闭。</p>
<pre><code class="lang-swift">.sheet(isPresented: $showPaymentDetails) {
    <span class="hljs-type">PaymentDetailView</span>(payment: selectedPaymentActivity!)
        .presentationDetents([.medium, .large])       
}
</code></pre>
<p>我们在第 18 章中使用了<code>.presentationDetents</code> 修饰器来实现了一个类似的Bottom Sheet。因此，我们重用了该章中大部分的代码。 如果你想了解更多关于 <code>BottomSheet</code> 的构建原理，你可以重读那一章。 在这里，我们将工作表定义为可扩展的底部工作表。 它以 <em>medium</em> 大小开始。 但是使用者可以向上拖动工作表以将其扩展为<em>large</em>尺寸。</p>
<h3 id="%E4%BD%BF%E7%94%A8core-data%E8%99%95%E7%90%86%E4%BA%A4%E6%98%93%E6%B4%BB%E5%8B%95">使用Core Data处理交易活动</h3>
<p>如前所述，所有交易活动都存放在数据库中，并通过 Core Data 进行管理。 在代码中，我们使用 <code>@FetchRequest</code> 属性包装器来读取交易活动，如下所示：</p>
<pre><code class="lang-swift">@<span class="hljs-type">FetchRequest</span>(
    entity: <span class="hljs-type">PaymentActivity</span>.entity(),
    sortDescriptors: [ <span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">PaymentActivity</span>.date, ascending: <span class="hljs-built_in">false</span>) ])
<span class="hljs-keyword">var</span> paymentActivities: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">PaymentActivity</span>&gt;
</code></pre>
<p>这个属性包装器让执行读取请求变得非常容易。 我们只需指定实体，即<code>PaymentActivity</code>，以及描述数据应如何排序。 然后，Core Data 框架会使用环境的托管物件内容（managed object context）来读取资料。 最重要的是，SwiftUI 会自动更新列表视图和相关视图。</p>
<p>从数据库中删除交易记录也是非常简单。 我们调用<code>context</code>的 <code>delete</code> 函数并指定要删除的交易就可以了：</p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">delete</span><span class="hljs-params">(payment: PaymentActivity)</span> </span>{
    <span class="hljs-keyword">self</span>.context.delete(payment)

    <span class="hljs-keyword">do</span> {
        try <span class="hljs-keyword">self</span>.context.save()
    } catch {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to save the context: <span class="hljs-subst">\(error.localizedDescription)</span>&quot;</span>)
    }
}
</code></pre>
<p>要了解如何添加新交易或更新现有交易记录，就要打开<code>PaymentFormView</code>。 如果你再次查看 <code>PaymentFormView.swift</code> ，你会发现 <code>save()</code> 函数：</p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">let</span> newPayment = payment ?? <span class="hljs-type">PaymentActivity</span>(context: context)

    newPayment.paymentId = <span class="hljs-type">UUID</span>()
    newPayment.name = paymentFormViewModel.name
    newPayment.type = paymentFormViewModel.type
    newPayment.date = paymentFormViewModel.date
    newPayment.amount = <span class="hljs-type">Double</span>(paymentFormViewModel.amount)!
    newPayment.address = paymentFormViewModel.location
    newPayment.memo = paymentFormViewModel.memo

    <span class="hljs-keyword">do</span> {
        try context.save()
    } catch {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to save the record...&quot;</span>)
        <span class="hljs-built_in">print</span>(error.localizedDescription)
    }
}
</code></pre>
<p>代码的第一行检查一下<code>payment</code> 是不是 nil。 如果是 nil 的话，我们就建立一个全新的<code>PaymentActivity</code>物件。 然后我们将<code>newPayment</code>填入所需值，最后就是调用 <code>context</code> 的<code>save()</code> 来添加/更新数据库中的记录。</p>
<h3 id="%E6%87%89%E7%94%A8%E6%93%B4%E5%B1%95%EF%BC%88extensions%EF%BC%89">应用扩展（Extensions）</h3>
<p>为方便起见，我们构建了两个扩展来格式化日期和数字。 在项目导航器中，您应该在 <em>Extension</em> 文件夹下找到两个档案。 先看一下<code>Date+Ext.swift</code>：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Date</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> today: <span class="hljs-type">Date</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Date</span>()
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> yesterday: <span class="hljs-type">Date</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Calendar</span>.current.date(byAdding: .day, value: -<span class="hljs-number">1</span>, to: <span class="hljs-type">Date</span>())!
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> tomorrow: <span class="hljs-type">Date</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Calendar</span>.current.date(byAdding: .day, value: <span class="hljs-number">1</span>, to: <span class="hljs-type">Date</span>())!
    }

    <span class="hljs-keyword">var</span> month: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Calendar</span>.current.component(.month, from: <span class="hljs-keyword">self</span>)
    }

    <span class="hljs-keyword">static</span> <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">fromString</span><span class="hljs-params">(string: String, with format: String = <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)</span> -&gt; <span class="hljs-title">Date</span>? </span>{
        <span class="hljs-keyword">let</span> dateFormatter = <span class="hljs-type">DateFormatter</span>()
        dateFormatter.dateFormat = format
        <span class="hljs-keyword">return</span> dateFormatter.date(from: string)
    }

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">string</span><span class="hljs-params">(with format: String = <span class="hljs-string">&quot;dd MMM yyyy&quot;</span>)</span> -&gt; <span class="hljs-title">String</span> </span>{
        <span class="hljs-keyword">let</span> dateFormatter = <span class="hljs-type">DateFormatter</span>()
        dateFormatter.dateFormat = format
        <span class="hljs-keyword">return</span> dateFormatter.string(from: <span class="hljs-keyword">self</span>)
    }
}
</code></pre>
<p>在上面的代码，我们建立了 <code>Date</code> 的扩展以提供额外的功能，包括：</p>
<ul>
<li>读取今天的日期</li>
<li>读取明天的日期</li>
<li>读取昨天的日期</li>
<li>读取日期的月份</li>
<li>将当前日期转换为字串，反之亦然</li>
</ul>
<p>为了将金额格式化，我们写了个 <code>NumberFormatter</code> 扩展以提供额外的功能：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">NumberFormatter</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">currency</span><span class="hljs-params">(from value: Double)</span> -&gt; <span class="hljs-title">String</span> </span>{
        <span class="hljs-keyword">let</span> formatter = <span class="hljs-type">NumberFormatter</span>()
        formatter.numberStyle = .decimal

        <span class="hljs-keyword">let</span> formattedValue = formatter.string(from: <span class="hljs-type">NSNumber</span>(value: value)) ?? <span class="hljs-string">&quot;&quot;</span>

        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&quot;</span> + formattedValue
    }
}
</code></pre>
<p>此函数接收一个值，并将它转换为字符串，然后再在最前面加上美元符号 ($)。</p>
<h3 id="%E8%99%95%E7%90%86%E8%BB%9F%E9%AB%94%E9%8D%B5%E7%9B%A4">处理软体键盘</h3>
<p>在 <code>PaymentFormView.swift</code> ，我们添加了以下修饰器：</p>
<pre><code class="lang-swift">.keyboardAdaptive()
</code></pre>
<p>这是一个自订的视图修饰器，为处理软体键盘而开发。 在 iOS 14以上版本，是不再需要此修饰器，但我特意添加了它，因为如果你的App要支持 iOS 13，就可能需要它。</p>
<p>在 iOS 13 上，软体键盘在未应用修饰器的情况下会遮掩部分表格。 举例，如果您尝试点击备忘录栏，它会完全隐藏在键盘后面。 相反，如果将修饰器附加到滚动视图，当键盘出现时，表格会自动向上移动。 在 iOS 14 上，系统本身会自动处理软体键盘的位置，防止它遮掩文字栏。</p>
<figure id="fig25.8"><img src="images/real-world-app/real-world-app-8.png" alt="图 25.8. 没使用 keyboardAdaptive (left), 使用了 keyboardAdaptive"><figcaption>图 25.8. 没使用 keyboardAdaptive (left), 使用了 keyboardAdaptive</figcaption></figure>
<p>现在让我们看看代码（<code>KeyboardAdaptive.swift</code>），以了解如何处理键盘事件：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyboardAdaptive</span>: <span class="hljs-title">ViewModifier</span> </span>{

    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentHeight: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span> -&gt; <span class="hljs-title">some</span> <span class="hljs-title">View</span> </span>{
        content
            .padding(.bottom, currentHeight)
            .onAppear(perform: handleKeyboardEvents)
    }

    private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">handleKeyboardEvents</span><span class="hljs-params">()</span> </span>{

        <span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.publisher(<span class="hljs-keyword">for</span>: <span class="hljs-type">UIResponder</span>.keyboardWillShowNotification
        ).compactMap { (notification) <span class="hljs-keyword">in</span>
            notification.userInfo?[<span class="hljs-string">&quot;UIKeyboardFrameEndUserInfoKey&quot;</span>] <span class="hljs-keyword">as</span>? <span class="hljs-type">CGRect</span>
        }.<span class="hljs-built_in">map</span> { rect <span class="hljs-keyword">in</span>
            rect.height
        }.subscribe(<span class="hljs-type">Subscribers</span>.<span class="hljs-type">Assign</span>(object: <span class="hljs-keyword">self</span>, keyPath: \.currentHeight))

        <span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.publisher(<span class="hljs-keyword">for</span>: <span class="hljs-type">UIResponder</span>.keyboardWillHideNotification
        ).compactMap { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-type">CGFloat</span>.zero
        }.subscribe(<span class="hljs-type">Subscribers</span>.<span class="hljs-type">Assign</span>(object: <span class="hljs-keyword">self</span>, keyPath: \.currentHeight))

    }
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardAdaptive</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">some</span> <span class="hljs-title">View</span> </span>{
        <span class="hljs-type">ModifiedContent</span>(content: <span class="hljs-keyword">self</span>, modifier: <span class="hljs-type">KeyboardAdaptive</span>())
    }
}
</code></pre>
<p>每当键盘出现（或消失）时，iOS 都会向App发送通知：</p>
<ul>
<li><em>keyboardWillShowNotification</em> - 当键盘即将出现时就会发送此通知</li>
<li><em>keyboardWillHideNotification</em> - 当键盘即将消失时发送此通知</li>
</ul>
<p>那么，我们如何利用这些通知来向上滚动表格呢？ 当App收到 <em>keyboardWillShowNotification</em> 时，它会向表格添加 padding 使其向上移动。 相反，当收到 <em>keyboardWillHideNotification</em> 时，我们就将padding设定为零。</p>
<p>在上面的代码，我们有一个状态变量来存放键盘的高度。 通过使用 Combine 框架，我们有一个发布者，当侦测到 <em>keyboardWillShowNotification</em> 就会立即发布键盘的当前高度。 此外，我们还有另一个发布者聆听 <em>keyboardWillHideNotification</em> 并发出<code>0</code>值。 对于这两个发布者，我们使用内置的 <code>assign</code> 将这些发布者发出的值传给 <code>currentHeight</code> 变量。</p>
<p>这就是移动键盘的方式和原理。 但是为什么我们需要有 <code>View</code> 扩展呢？</p>
<p>该代码无需扩展也可运作。 您可以将代码写成这样来处理键盘事件：</p>
<pre><code class="lang-swift">.modifier(<span class="hljs-type">KeyboardAdaptive</span>())
</code></pre>
<p>为了使代码更简洁，我们创建了扩展并添加了 <code>keyboardAdaptive()</code> 函数。 之后，就可以直接将修饰哭附加到任何视图，如下所示：</p>
<pre><code class="lang-swift">.keyboardAdaptive()
</code></pre>
<p>由于此视图修饰器仅适用于 iOS 13，因此我们在 <code>keyboardAdaptive()</code> 函数中使用 <code>#available</code> 来检查 OS 版本：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardAdaptive</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">some</span> <span class="hljs-title">View</span> </span>{
        <span class="hljs-keyword">if</span> #available(iOS <span class="hljs-number">14.0</span>, *) {
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-keyword">self</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-type">ModifiedContent</span>(content: <span class="hljs-keyword">self</span>, modifier: <span class="hljs-type">KeyboardAdaptive</span>()))
        }
    }
}
</code></pre>
<h3 id="%E7%B8%BD%E7%B5%90">总结</h3>
<p>这就是我们从零开始构建个人理财App的方式。 此章使用的大多数技术对您来说都不是新的，我们只是将所学应用出来。</p>
<p>SwiftUI 是一个非常强大且好用的框架，它允许您使用比 UIKit 更少的代码构建相同的App。 如果您对 UIKit 有一定的开发经验，您就会知道如使用UIKit创建个人理财App，将会花费您更多的时间和需要写更多代码。 我真的希望你喜欢学习 SwiftUI 并使用这个新框架构建 UI。 </p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./swiftui-searchbar.html" class="navigation navigation-prev " aria-label="Previous page: 建立搜寻栏视图并使用自订绑定（Custom Binding）"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./swiftui-appstoreanimation.html" class="navigation navigation-next " aria-label="Next page: 创建类似App Store使用的动画视图转换"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":"white","family":"serif","size":3},"image-captions":{"caption":"_CAPTION_","variable_name":"_pictures"}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
