<!DOCTYPE HTML>
<html lang="zh-tw" >
    
    <head>
        
        <meta charset=utf-8"UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=11; IE=10; IE=9; IE=8; IE=7; IE=EDGE" />
        <title>如何使用 Core Data 建立 ToDo App | 精通 SwiftUI - iOS 16 版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.0.1">
        <meta name="author" content="Simon Ng">
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    <link rel="next" href="./swiftui-uikit.html" />
    
    
    <link rel="prev" href="./swiftui-json.html" />
    

        
    </head>
    <body>
        
        
    <link rel="stylesheet" href="gitbook/style.css">
    
        
        <link rel="stylesheet" href="gitbook/plugins/gitbook-plugin-image-captions/image-captions.css">
        
    
    
        <link rel="stylesheet" href="././styles/website.css">
    

        
    <div class="book" data-level="22" data-basepath="." data-revision="Thu Dec 01 2022 17:36:55 GMT+0800 (HKT)">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="输入并搜寻" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
            
            <li>
                <a href="https://www.appcoda.com.tw" target="blank" class="custom-link">Made by AppCoda</a>
            </li>
        
            
            <li>
                <a href="https://www.appcoda.com.tw/contact" target="blank" class="custom-link">Contact us / Support</a>
            </li>
        
            
            <li>
                <a href="http://twitter.com/share?text=Mastering%20SwiftUI%20via%20@appcodamobile&amp;url=https://www.appcoda.com.tw/swiftui/&amp;hashtags=swiftlang" target="blank" class="custom-link">Tweet this book</a>
            </li>
        
        

        
        <li class="divider"></li>
        

        
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                        <i class="fa fa-check"></i>
                        
                        序言
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="swiftui-basics.html">
            
                
                    <a href="./swiftui-basics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        SwiftUI 介绍
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="swiftui-text.html">
            
                
                    <a href="./swiftui-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        SwiftUI 入门 - 文字的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="swiftui-images.html">
            
                
                    <a href="./swiftui-images.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        图片的处理
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="4" data-path="swiftui-stacks.html">
            
                
                    <a href="./swiftui-stacks.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        以堆叠布局使用者介面
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="5" data-path="swiftui-scrollview.html">
            
                
                    <a href="./swiftui-scrollview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        ScrollView 与 Carousel UI 的建立
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="6" data-path="swiftui-buttons.html">
            
                
                    <a href="./swiftui-buttons.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                        SwiftUI 按钮与渐层
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="7" data-path="swiftui-state.html">
            
                
                    <a href="./swiftui-state.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                        状态(State)与绑定(Binding)
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="8" data-path="swiftui-path-shape.html">
            
                
                    <a href="./swiftui-path-shape.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                        实作路径(Path)与形状(Shape)来画线与圆饼图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="9" data-path="swiftui-animation.html">
            
                
                    <a href="./swiftui-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                        基础动画与转场
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="10" data-path="swiftui-list.html">
            
                
                    <a href="./swiftui-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                        动态列表、 ForEach 与 Identifiable 的使用方法
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="11" data-path="swiftui-navigation.html">
            
                
                    <a href="./swiftui-navigation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                        导览UI与导览列客制化运用
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="12" data-path="swiftui-modal.html">
            
                
                    <a href="./swiftui-modal.html">
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                        强制回应视图、浮动按钮与提示的实作
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="13" data-path="swiftui-form.html">
            
                
                    <a href="./swiftui-form.html">
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                        以选取器(Picker)、开关(Toggle)与步进器(Stepper)来建立一个表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="14" data-path="swiftui-form-data.html">
            
                
                    <a href="./swiftui-form-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                        使用 Combine 与 Environment 物件进行资料分享
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="15" data-path="swiftui-form-registration.html">
            
                
                    <a href="./swiftui-form-registration.html">
                        <i class="fa fa-check"></i>
                        
                            <b>15.</b>
                        
                        以 Combine 与 视图模型建立一个注册表单
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="16" data-path="swiftui-actionsheet-context.html">
            
                
                    <a href="./swiftui-actionsheet-context.html">
                        <i class="fa fa-check"></i>
                        
                            <b>16.</b>
                        
                        滑动删除、内容选单与动作列表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="17" data-path="swiftui-gestures.html">
            
                
                    <a href="./swiftui-gestures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>17.</b>
                        
                        认识手势（Gestures）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="18" data-path="swiftui-bottom-sheet.html">
            
                
                    <a href="./swiftui-bottom-sheet.html">
                        <i class="fa fa-check"></i>
                        
                            <b>18.</b>
                        
                        以SwiftUI 手势与 GeometryReader 建立一个底部展开式页面
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="19" data-path="swiftui-trip-tinder.html">
            
                
                    <a href="./swiftui-trip-tinder.html">
                        <i class="fa fa-check"></i>
                        
                            <b>19.</b>
                        
                        使用手势与动画建立 Tinder 风格的 UI
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="20" data-path="swiftui-advanced-animations.html">
            
                
                    <a href="./swiftui-advanced-animations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>20.</b>
                        
                        建立像 Apple Wallet App 的动画和转场效果
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="21" data-path="swiftui-json.html">
            
                
                    <a href="./swiftui-json.html">
                        <i class="fa fa-check"></i>
                        
                            <b>21.</b>
                        
                        JSON、滑杆的运用与资料过滤
                    </a>
                
            
            
        </li>
    
        <li class="chapter active" data-level="22" data-path="swiftui-core-data.html">
            
                
                    <a href="./swiftui-core-data.html">
                        <i class="fa fa-check"></i>
                        
                            <b>22.</b>
                        
                        如何使用 Core Data 建立 ToDo App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="23" data-path="swiftui-uikit.html">
            
                
                    <a href="./swiftui-uikit.html">
                        <i class="fa fa-check"></i>
                        
                            <b>23.</b>
                        
                        利用 UIViewRepresentable 整合UIKit 组件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="24" data-path="swiftui-searchbar.html">
            
                
                    <a href="./swiftui-searchbar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>24.</b>
                        
                        建立搜寻栏视图并使用自订绑定（Custom Binding）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="25" data-path="swiftui-real-world-app.html">
            
                
                    <a href="./swiftui-real-world-app.html">
                        <i class="fa fa-check"></i>
                        
                            <b>25.</b>
                        
                        把所学应用出来！构建个人理财App
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="26" data-path="swiftui-appstoreanimation.html">
            
                
                    <a href="./swiftui-appstoreanimation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>26.</b>
                        
                        创建类似App Store使用的动画视图转换
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="27" data-path="swiftui-carousel.html">
            
                
                    <a href="./swiftui-carousel.html">
                        <i class="fa fa-check"></i>
                        
                            <b>27.</b>
                        
                        如何建立图像轮播（Image Carousel）
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="28" data-path="swiftui-expandable-list.html">
            
                
                    <a href="./swiftui-expandable-list.html">
                        <i class="fa fa-check"></i>
                        
                            <b>28.</b>
                        
                        如何建立展开式列表视图和大纲视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="29" data-path="swiftui-gridlayout.html">
            
                
                    <a href="./swiftui-gridlayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>29.</b>
                        
                        使用 LazyVGrid 和 LazyHGrid 构建集合视图
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="30" data-path="swiftui-progress-ring.html">
            
                
                    <a href="./swiftui-progress-ring.html">
                        <i class="fa fa-check"></i>
                        
                            <b>30.</b>
                        
                        使用 Shape 和 Animatable 开发带动画的环形进度条
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="31" data-path="swiftui-library.html">
            
                
                    <a href="./swiftui-library.html">
                        <i class="fa fa-check"></i>
                        
                            <b>31.</b>
                        
                        如何使用 AnimatableModifier 和 LibraryContentProvider
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="32" data-path="swiftui-texteditor.html">
            
                
                    <a href="./swiftui-texteditor.html">
                        <i class="fa fa-check"></i>
                        
                            <b>32.</b>
                        
                        使用 TextEditor 支援多行文字输入
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="33" data-path="swiftui-matchedgeometry.html">
            
                
                    <a href="./swiftui-matchedgeometry.html">
                        <i class="fa fa-check"></i>
                        
                            <b>33.</b>
                        
                        使用 matchedGeometryEffect为 App 建立绚丽的视图动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="34" data-path="swiftui-grid-animation.html">
            
                
                    <a href="./swiftui-grid-animation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>34.</b>
                        
                        ScrollViewReader 和网格动画
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="35" data-path="swiftui-tabview.html">
            
                
                    <a href="./swiftui-tabview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>35.</b>
                        
                        标签视图的运用与自订标签列
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="36" data-path="swiftui-asyncimage.html">
            
                
                    <a href="./swiftui-asyncimage.html">
                        <i class="fa fa-check"></i>
                        
                            <b>36.</b>
                        
                        利用 AsyncImage 非同步加载和显示图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="37" data-path="swiftui-searchable.html">
            
                
                    <a href="./swiftui-searchable.html">
                        <i class="fa fa-check"></i>
                        
                            <b>37.</b>
                        
                        利用 Searchable 建立搜寻栏
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="38" data-path="swiftui-charts.html">
            
                
                    <a href="./swiftui-charts.html">
                        <i class="fa fa-check"></i>
                        
                            <b>38.</b>
                        
                        利用 Charts 框架建立图表
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="39" data-path="swiftui-live-text.html">
            
                
                    <a href="./swiftui-live-text.html">
                        <i class="fa fa-check"></i>
                        
                            <b>39.</b>
                        
                        利用 Live Text API 从图片中撷取文本
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="40" data-path="swiftui-sharelink.html">
            
                
                    <a href="./swiftui-sharelink.html">
                        <i class="fa fa-check"></i>
                        
                            <b>40.</b>
                        
                        透过 ShareLink 来分享文本和图像等资料
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="41" data-path="swiftui-imagerenderer.html">
            
                
                    <a href="./swiftui-imagerenderer.html">
                        <i class="fa fa-check"></i>
                        
                            <b>41.</b>
                        
                        利用 ImageRenderer API 轻松把 SwiftUI 视图转换为图像
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="42" data-path="swiftui-pdf-doc.html">
            
                
                    <a href="./swiftui-pdf-doc.html">
                        <i class="fa fa-check"></i>
                        
                            <b>42.</b>
                        
                        如何把 SwiftUI 视图转换为 PDF 文件
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="43" data-path="swiftui-gauge.html">
            
                
                    <a href="./swiftui-gauge.html">
                        <i class="fa fa-check"></i>
                        
                            <b>43.</b>
                        
                        使用 Gauge 视图显示进度并创建速度计
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="44" data-path="swiftui-grid.html">
            
                
                    <a href="./swiftui-grid.html">
                        <i class="fa fa-check"></i>
                        
                            <b>44.</b>
                        
                        使用Grid API 创建网格布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="45" data-path="swiftui-anylayout.html">
            
                
                    <a href="./swiftui-anylayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>45.</b>
                        
                        利用 AnyLayout 切换 UI 布局
                    </a>
                
            
            
        </li>
    
        <li class="chapter " data-level="46" data-path="swiftui-navigationstack.html">
            
                
                    <a href="./swiftui-navigationstack.html">
                        <i class="fa fa-check"></i>
                        
                            <b>46.</b>
                        
                        使用新的 NavigationStack 视图构建资料导向的导航
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                本书使用 GitBook 释出
            </a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="目录"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="搜寻"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="字型设定"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">衬线体</button>
        <button type="button" data-font="1" class="button">无衬线体</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">白色</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">棕褐色</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">夜间</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="分享"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">
                    分享到 Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    分享到 Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    分享到 Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    分享到 Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    分享到 Instapaper
                </button>
            </div>
        </div>
    </div>
    

    
    
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >精通 SwiftUI - iOS 16 版</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="%E7%AC%AC-22-%E7%AB%A0-br-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-core-data-%E5%BB%BA%E7%AB%8B-todo-app">第 22 章<br>如何使用 Core Data 建立 ToDo App</h1>
<p>iOS App 开发的一个常见问题是我们如何使用 Core Data 和 SwiftUI 将数据永久保存在内置数据库中。 在本章中，我们将通过构建一个 ToDo 应用程序来回答这个问题。</p>
<p>由于 ToDo 这个范例程式使用 List 和 Combine 来处理数据展示和共享，我假设你已经阅读了以下章节：</p>
<ul>
<li>第 7 章 - 状态(State)与绑定(Binding)</li>
<li>第 10 章 - 动态列表、 ForEach 与 Identifiable 的使用方法</li>
<li>第 14 章 - 使用 Combine 与 Environment 物件进行资料分享</li>
</ul>
<p>如果你还未阅读或忘记了Combine 和Environment Objects 是什么，请先阅读这些章节。</p>
<p>究竟你会将会做什么以理解 Core Data？ 我已经构建了范例App的核心部分，你并不需要从头开始构建 ToDo App。 但是，它不能永久保存数据。 更具体地说，它只能将待办事项保存在记忆体当中。 每当用户关闭App并再次启动它时，所有数据都会消失。 我们将修改这个范例 App 并将其转换为使用 Core Data 将数据永久保存到本地数据库。 图 22.1 显示了 ToDo App 的一些示例屏幕截图。</p>
<figure id="fig22.1"><img src="images/core-data/swiftui-core-data-1.png" alt="图 22.1. ToDo app"><figcaption>图 22.1. ToDo app</figcaption></figure>
<p>在我们开始修改之前，我会先介绍一下这个 Starter 项目，以便你完全理解当中的代码。</p>
<p>除了 Core Data，你还将会学习如何自定义切换的样式。 看看上面的截图，该核取方块实际上是 SwiftUI 的切换视图。 我将向你展示如何透过自定义 Toggle 的样式来建立这些核取方块。</p>
<p>本章有很多内容要讲，让我们开始吧！</p>
<h3 id="core-data-%E4%BB%8B%E7%B4%B9">Core Data 介绍</h3>
<p>在我们查看 ToDo App的Starter项目之前，让我向你简单介绍一下 Core Data 以及你将如何在 SwiftUI 项目中使用它。 </p>
<h4 id="%E4%BB%80%E9%BA%BC%E6%98%AF-core-data">什么是 Core Data?</h4>
<p>首先，不要将 Core Data 框架与数据库混淆。 Core Data 不是数据库。 它只是一个供开发人员管理持久存储上的数据并与之交互的框架。 尽管 SQLite 数据库是 iOS 上 Core Data 的预设持久性储存器（ Persistent Storage ），但持久性储存器不限于数据库。 例如，你还可以利用 Core Data 来管理档案库文件（例如 XML）中的数据。</p>
<p>Core Data 框架只是将开发人员与永久存储的内部细节屏蔽开来。 以 SQLite 数据库为例， 你不需要知道如何连接到数据库，也不需要了解 SQL 来检索数据记录。 你只需要弄清楚如何使用Core Data API，例如 <code>NSManagedObjectContext</code> 和托管物件模型（Managed Object Model）。</p>
<p>这看起来有点复杂，是吧？不用担心。 在我们将 ToDo App从数组转换为 Core Data 之后，你就会明白我的意思。</p>
<h3 id="%E4%BD%BF%E7%94%A8-core-data-%E6%A8%A1%E6%9D%BF">使用 Core Data 模板</h3>
<p>使用 Core Data 的最简单方式，就是建立一个新专案时启用 Core Data 选项 。你也可以试一试。 启动 Xcode 并使用 <em>App</em> 模板建立一个新项目。 将其命名为你喜欢的名称，但请确保选中 <em>Core Data</em> 选项。</p>
<figure id="fig22.2"><img src="images/core-data/swiftui-core-data-2.png" alt="图 22.2. 建立一个启用 Core Data 的新项目"><figcaption>图 22.2. 建立一个启用 Core Data 的新项目</figcaption></figure>
<p>透过使用 Core Data，Xcode 将为你生成所有必需的代码和托管物件模型。 建立项目后，你应该会看到一个名为“CoreDataTest.xcdatamodeld”的新文件。 在 Xcode 中，托管物件模型的副档名为“.xcdatamodeld”。 这是为你的项目生成的托管物件模型，也是你定义持久性物件的地方。</p>
<p>看一下 <code>Persistence.swift</code> 文件，这是 Xcode 生成的另一个文件。 该文件包含用于加载托管物件模型并将数据保存到持久性储存器的代码。</p>
<figure id="fig22.3"><img src="images/core-data/swiftui-core-data-3.png" alt="图 3. Core Data的附加代码"><figcaption>图 3. Core Data的附加代码</figcaption></figure>
<p>如果你之前使用过 UIKit 开发App，你通常会使用容器来管理数据库或其他持久性储存器中的数据。 在 SwiftUI 中，它有点不同。 我们很少直接使用这个容器。 相反，SwiftUI 将托管物件内容（Managed Object Context）注入到SwiftUI 环境中，以便任何视图都可以检索物件内容并管理数据。</p>
<p> 现在开启 <code>CoreDataTestApp.swift</code> ， Xcode 添加了一个常数来保存 <code>PersistenceController</code> 。另外，它还加了一行代码将托管对像内容注入到环境中。</p>
<figure id="fig22.4"><img src="images/core-data/swiftui-core-data-4.png" alt="图 4. 将托管物件内容注入到环境中"><figcaption>图 4. 将托管物件内容注入到环境中</figcaption></figure>
<p>以上所讲的，就是在启用 Core Data 选项时由 Xcode 生成的代码和文件。 如果打开<code>ContentView.swift</code>，Xcode 还会生成示例代码，用于从本地数据存储加载数据。 查看代码以了解其工作原理。 一般来说，要在本地数据库上保存和管理数据，步骤如下：</p>
<ol>
<li><p>利用模型编辑器（ Data Model Editor ）在资料模型 (i.e. <code>.xcdatamodeld</code>) 建立实体（ Entity ）。</p>
</li>
<li><p>建立实体的相对应的托管物件（应继承自 <code>NSManagedObject</code>）。</p>
</li>
<li><p>在需要保存和更新数据的视图中，使用 <code>@Environment</code> 从环境中获取托管物件内容，如下所示：</p>
<pre><code class="lang-swift">@<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> context
</code></pre>
<p>然后建立托管物件并使用托管物件内容的<code>save</code>方法将物件添加到数据库中。 这是相关的代码：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> task = <span class="hljs-type">ToDoItem</span>(context: context)
task.id = <span class="hljs-type">UUID</span>()
task.name = name
task.priority = priority
task.isComplete = isComplete
</code></pre>
</li>
<li><p>至于数据检索，Apple 引入了一个名为<code>@FetchRequest</code>的属性包装器，供你从持久存储器获取资料。 以下是相关的代码：</p>
<pre><code class="lang-swift">@<span class="hljs-type">FetchRequest</span>(
   entity: <span class="hljs-type">ToDoItem</span>.entity(),
   sortDescriptors: [ <span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">ToDoItem</span>.priorityNum, ascending: <span class="hljs-built_in">false</span>) ])
<span class="hljs-keyword">var</span> todoItems: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">ToDoItem</span>&gt;
</code></pre>
<p>此属性包装器使执行读取请求变得非常简单。 你只需要指定要检索的实体物件以及数据的排序方式， 然后框架将使用环境的托管物件内容来获取数据。 最重要的是，取得数据之后，SwiftUI 会自动更新所有相关的视图。</p>
</li>
</ol>
<p>这就是你在 SwiftUI 项目中使用 Core Data 的方式。 我知道你可能对某些程序感到困惑， 本节只是一个非常初步的简介。 稍后，当你修改范例程式时，我们将更详细解释这些程序。</p>
<h3 id="%E4%BA%86%E8%A7%A3-todo-app-%E7%AF%84%E4%BE%8B%E9%81%8B%E4%BD%9C">了解 ToDo App 范例运作</h3>
<p>现在你对 Core Data 有了基本的了解，让我和你一起完成这个范例App。 稍后，我们将修改此 ToDo App，让它能永久保存待办事项。 现在，如前所述，所有数据都存储在记忆体当中，并且会在App重新启动时消失。</p>
<p>首先，请从 <a href="https://www.appcoda.com/resources/swiftui4/SwiftUIToDoListStarter.zip" target="_blank">https://www.appcoda.com/resources/swiftui4/SwiftUIToDoListStarter.zip</a> 下载启动项目。 解压档案并在 Xcode 中打开 <code>ToDoList.xcodeproj</code>。 选择 <code>ContentView.swift</code> 并预览 UI。 你应该会看到如图 22.5 所示的屏幕。</p>
<figure id="fig22.5"><img src="images/core-data/swiftui-core-data-5.png" alt="图 22.5. 预览范例App"><figcaption>图 22.5. 预览范例App</figcaption></figure>
<p>在预览框或模拟器中运行App。 按 + 并添加待办事项。 之后，再重复添加更多项目。 然后App就会列出所有待办事项。 在待办事项的格子按一下，App就会划掉该项目。</p>
<figure id="fig22.6"><img src="images/core-data/swiftui-core-data-6.png" alt="图 22.6. 添加新事项"><figcaption>图 22.6. 添加新事项</figcaption></figure>
<h4 id="%E5%A6%82%E4%BD%95%E9%A1%AF%E7%A4%BA%E5%BE%85%E8%BE%A6%E4%BA%8B%E9%A0%85%E5%88%97%E8%A1%A8">如何显示待办事项列表</h4>
<p>先让我们看一下代码，以便你了解这些代码背后的运作原理。 首先，我们从模型类开始。 在 <em>Model</em> 文件夹中打开 <code>ToDoItem.swift</code>。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Priority</span>: <span class="hljs-title">Int</span> </span>{
    <span class="hljs-keyword">case</span> low = <span class="hljs-number">0</span>
    <span class="hljs-keyword">case</span> normal = <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> high = <span class="hljs-number">2</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToDoItem</span>: <span class="hljs-title">ObservableObject</span>, <span class="hljs-title">Identifiable</span> </span>{
    <span class="hljs-keyword">var</span> id = <span class="hljs-type">UUID</span>()
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> priority: <span class="hljs-type">Priority</span> = .normal
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isComplete: <span class="hljs-type">Bool</span> = <span class="hljs-built_in">false</span>

    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, priority: <span class="hljs-type">Priority</span> = .normal, isComplete: <span class="hljs-type">Bool</span> = <span class="hljs-built_in">false</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.priority = priority
        <span class="hljs-keyword">self</span>.isComplete = isComplete
    }
}
</code></pre>
<p>这个范例App是一个普通 ToDo App的简化版本。 每个待办事项（或任务）具有三个属性：<em>name</em>、<em>priority</em> 和 <em>isComplete</em>（即事项的状态）。 这个类别采用了<code>ObservableObject</code> 协议。 这三个属性都用<code>@Published</code> 标记，当其中的值发生任何更改时就会自动通知订阅者。 稍后，在 ContentView 的实作中，SwiftUI 会不时观察数值的变化并相应地更新视图。 例如，当 <code>isComplete</code> 的值发生变化时，它会切换核取方块。</p>
<p>这个类别也符合<code>Identifiable</code> 协议，这样<code>ToDoItem</code> 的每个实体（instance）都有一个独一无二的识别码。 稍后，我们将使用 <code>ForEach</code> 和 <code>List</code> 来显示待办事项。 这就是为什么我们需要采用协议并创建 <code>id</code> 属性。</p>
<p>现在让我们转到视图并从<code>ContentView.swift</code> 开始。 假设你已经阅读了第 10 章，你应该理解大部分代码。 内容视图包含三个主要部分，它们嵌入在一个“ZStack”中：</p>
<ol>
<li>显示所有待办事项的列表视图。</li>
<li>没有待办事项时显示的空视图 (NoDataView)。</li>
<li>当用户点击 + 按钮时显示的“添加新事项”视图。</li>
</ol>
<p>先看第一个<code>VStack</code>：</p>
<pre><code class="lang-swift"><span class="hljs-type">VStack</span> {

    <span class="hljs-type">HStack</span> {
        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;ToDo List&quot;</span>)
            .font(.system(size: <span class="hljs-number">40</span>, weight: .black, design: .rounded))

        <span class="hljs-type">Spacer</span>()

        <span class="hljs-type">Button</span>(action: {
            <span class="hljs-keyword">self</span>.showNewTask = <span class="hljs-built_in">true</span>

        }) {
            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">&quot;plus.circle.fill&quot;</span>)
                .font(.largeTitle)
                .foregroundColor(.purple)
        }
    }
    .padding()

    <span class="hljs-type">List</span> {

        <span class="hljs-type">ForEach</span>(todoItems) { todoItem <span class="hljs-keyword">in</span>
            <span class="hljs-type">ToDoListRow</span>(todoItem: todoItem)
        }

    }
}
.rotation3DEffect(<span class="hljs-type">Angle</span>(degrees: showNewTask ? <span class="hljs-number">5</span> : <span class="hljs-number">0</span>), axis: (x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span>))
.offset(y: showNewTask ? -<span class="hljs-number">50</span> : <span class="hljs-number">0</span>)
.animation(.easeOut)
</code></pre>
<p>我加了一个名为 <code>todoItems</code> 的变数来保存所有的待办事项。 这个变数标有<code>@State</code>，以便在有任何更改时更新列表。 在 List 视图中，我们使用 ForEach 以显示所有项目。</p>
<p>另外，我们有一个名为<code>ToDoListRow</code>的独立视图以处理列表的行：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ToDoListRow</span>: <span class="hljs-title">View</span> </span>{

    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> todoItem: <span class="hljs-type">ToDoItem</span>

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Toggle</span>(isOn: <span class="hljs-keyword">self</span>.$todoItem.isComplete) {
            <span class="hljs-type">HStack</span> {
                <span class="hljs-type">Text</span>(<span class="hljs-keyword">self</span>.todoItem.name)
                    .strikethrough(<span class="hljs-keyword">self</span>.todoItem.isComplete, color: .black)
                    .bold()
                    .animation(.<span class="hljs-keyword">default</span>)

                <span class="hljs-type">Spacer</span>()

                <span class="hljs-type">Circle</span>()
                    .frame(width: <span class="hljs-number">10</span>, height: <span class="hljs-number">10</span>)
                    .foregroundColor(<span class="hljs-keyword">self</span>.color(<span class="hljs-keyword">for</span>: <span class="hljs-keyword">self</span>.todoItem.priority))
            }
        }.toggleStyle(<span class="hljs-type">CheckboxStyle</span>())
    }

    private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-keyword">for</span> priority: Priority)</span> -&gt; <span class="hljs-title">Color</span> </span>{
        <span class="hljs-keyword">switch</span> priority {
        <span class="hljs-keyword">case</span> .high: <span class="hljs-keyword">return</span> .red
        <span class="hljs-keyword">case</span> .normal: <span class="hljs-keyword">return</span> .orange
        <span class="hljs-keyword">case</span> .low: <span class="hljs-keyword">return</span> .green
        }
    }
}
</code></pre>
<p>这个视图接受一个待办事项，它是一个<code>ObservableObject</code>。 这意味着该待办事项有任何更改时，相关的视图将自动更新UI。</p>
<p>对于每一行的待办事项，由三部分组成：</p>
<ol>
<li>切换（Toggle）/ 核取方块（Checkbox） - 提示事项是否完成。</li>
<li>文字标签 - 显示事项名称</li>
<li>点/圆圈 - 显示事项的优先次序</li>
</ol>
<p>第二和第三部分非常简单。 至于核取方块，这个比较值得更深入的讨论。 SwiftUI 提供有一个名为<code>Toggle</code>的标准控件。 在前面的章节中，我们用它来建立一个App设定画要。 这里的切换（Toggle）更像是一个开关，可让你打开或关闭，但在 ToDo App中，我们想让切换看起来像一个核取方块。</p>
<h4 id="%E8%87%AA%E8%A8%82-toggle-%E7%9A%84%E5%A4%96%E8%A7%80">自订 Toggle 的外观</h4>
<p>与我们在第 6 章中讨论的 <code>Button</code> 类似，<code>Toggle</code> 也允许开发人员自定义其样式。 你需要做的就是实现<code>ToggleStyle</code>协议。 在项目导航器中，打开 <code>CheckBoxStyle.swift</code> 查看：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CheckboxStyle</span>: <span class="hljs-title">ToggleStyle</span> </span>{

    <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span> -&gt; <span class="hljs-title">some</span> <span class="hljs-title">View</span> </span>{

        <span class="hljs-keyword">return</span> <span class="hljs-type">HStack</span> {

            <span class="hljs-type">Image</span>(systemName: configuration.isOn ? <span class="hljs-string">&quot;checkmark.circle.fill&quot;</span> : <span class="hljs-string">&quot;circle&quot;</span>)
                .resizable()
                .frame(width: <span class="hljs-number">24</span>, height: <span class="hljs-number">24</span>)
                .foregroundColor(configuration.isOn ? .purple : .gray)
                .font(.system(size: <span class="hljs-number">20</span>, weight: .bold, design: .<span class="hljs-keyword">default</span>))
                .onTapGesture {
                    configuration.isOn.toggle()
                }

            configuration.label

        }

    }
}
</code></pre>
<p>在代码中，我们实作了<code>makeBody</code>方法，这是协议的要求。 我们加入了一个图像视图，取决于切换的状态（即<code>configuration.isOn</code>），它将显示一个选框图像或一个圆形图像。 这就是如何自定义切换样式的方法。</p>
<p>要使用 <code>CheckboxStyle</code>，请将 <code>toggleStyle</code> 修饰器附加到 <code>Toggle</code> 并指定核取方块样式，如下所示：</p>
<pre><code class="lang-swift">.toggleStyle(<span class="hljs-type">CheckboxStyle</span>())
</code></pre>
<h4 id="%E8%99%95%E7%90%86%E7%A9%BA%E5%88%97%E8%A1%A8%E8%A6%96%E5%9C%96">处理空列表视图</h4>
<p>当阵列中没有项目时，我们显示一个图像视图而不是一个空的列表视图。 这个并不是必须做，但是，我认为它使App看起来更好，并让使用者知道在App首次启动时该做什么。</p>
<pre><code class="lang-swift"><span class="hljs-comment">// 如果没有资料，就显示一个空视图</span>
<span class="hljs-keyword">if</span> todoItems.<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span> {
    <span class="hljs-type">NoDataView</span>()
}
</code></pre>
<p>由于我们有一个 <code>ZStack</code> 来嵌入视图，所以很容易控制这个空视图何时显示。那就是当阵列为空时显示出来。</p>
<h4 id="%E9%A1%AF%E7%A4%BA%E6%B7%BB%E5%8A%A0%E4%BA%8B%E9%A0%85%E8%A6%96%E5%9C%96">显示添加事项视图</h4>
<p>当使用者点击右上角的 + 按钮时，App 会显示“NewToDoView”。 此视图覆盖在列表视图的顶部，看起来像一个由画面底弹出来的页面。 我们还添加了一个空白视图来使列表视图变暗。</p>
<p>下面是代码供参考：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> showNewTask {
    <span class="hljs-type">BlankView</span>(bgColor: .black)
        .opacity(<span class="hljs-number">0.5</span>)
        .onTapGesture {
            <span class="hljs-keyword">self</span>.showNewTask = <span class="hljs-built_in">false</span>
        }

    <span class="hljs-type">NewToDoView</span>(isShow: $showNewTask, todoItems: $todoItems, name: <span class="hljs-string">&quot;&quot;</span>, priority: .normal)
        .transition(.move(edge: .bottom))
        .animation(.interpolatingSpring(stiffness: <span class="hljs-number">200.0</span>, damping: <span class="hljs-number">25.0</span>, initialVelocity: <span class="hljs-number">10.0</span>))
}
</code></pre>
<h4 id="%E4%BA%86%E8%A7%A3%E6%B7%BB%E5%8A%A0%E4%BA%8B%E9%A0%85%E8%A6%96%E5%9C%96">了解添加事项视图</h4>
<p>现在让我和你讨论一下 <code>NewToDoView.swift</code> 中的代码，该代码用于让使用者添加新任务或待办事项。 你可以参考图 22.6 或简单地打开档案进行预览，看看该视图的外观。</p>
<p><code>NewToDoView</code> 接受两个绑定：<em>isShow</em> 和 <em>todoItems</em>。 <code>isShow</code> 参数控制这个 <em>Add New Task</em> 视图是否应该出现在荧幕上。 <code>todoItems</code> 变数储存了对待办事项阵列的参考。 我们需要方法呼叫者将绑定传递给 <code>todoItems</code>，以便我们可以将新事项加进阵列。</p>
<pre><code class="lang-swift">@<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> isShow: <span class="hljs-type">Bool</span>
@<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> todoItems: [<span class="hljs-type">ToDoItem</span>]

@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> priority: <span class="hljs-type">Priority</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isEditing = <span class="hljs-built_in">false</span>
</code></pre>
<p>在视图中，我们让用户输入事项名称并设置其优先次序（低/正常/高）。 状态变数<code>isEditing</code>标示是否进入编辑模式。 为避免软体键盘遮挡编辑画面，App将在使用者编辑文字时稍为向上移动视图。</p>
<pre><code class="lang-swift"><span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;Enter the task description&quot;</span>, text: $name, onEditingChanged: { (editingChanged) <span class="hljs-keyword">in</span>

    <span class="hljs-keyword">self</span>.isEditing = editingChanged

})


...

.offset(y: isEditing ? -<span class="hljs-number">320</span> : <span class="hljs-number">0</span>)
</code></pre>
<p>点击 <em>Save</em> 按钮后，我们验证文字栏是否有输入文字。 如果使用者有输入文字，我们会建立一个新的 <code>ToDoItem</code> 并呼叫 <code>addTask</code> 方法将其附加到 <code>todoItems</code> 阵列。相反，我们就什么都不做了。</p>
<pre><code class="lang-swift"><span class="hljs-type">Button</span>(action: {

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.name.trimmingCharacters(<span class="hljs-keyword">in</span>: .whitespaces) == <span class="hljs-string">&quot;&quot;</span> {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">self</span>.isShow = <span class="hljs-built_in">false</span>
    <span class="hljs-keyword">self</span>.addTask(name: <span class="hljs-keyword">self</span>.name, priority: <span class="hljs-keyword">self</span>.priority)

}) {
    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Save&quot;</span>)
        .font(.system(.headline, design: .rounded))
        .frame(minWidth: <span class="hljs-number">0</span>, maxWidth: .infinity)
        .padding()
        .foregroundColor(.white)
        .background(<span class="hljs-type">Color</span>.purple)
        .cornerRadius(<span class="hljs-number">10</span>)
}
.padding(.bottom)
</code></pre>
<p>由于 <code>todoItems</code> 阵列是一个状态变数，列表视图会自动更新并显示新事项。 这就是整个代码的运作原理。 如果你不明白 <em>Add task</em> 视图是如何显示在荧幕底部的话，请参阅第 18 章。</p>
<h3 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-core-data">如何使用 Core Data</h3>
<p>现在我已经为你介绍了这个ToDo项目，是时候将App转换为使用 Core Data 将待办事项存储在数据库中了。 一开始，我们曾建立了一个启用了 <em>Core Data</em> 的空白项目。 通过选中 Core Data 选框，Xcode 会自动生成 Core Data 项目的基本框架。 这一次，我将向你展示如何手动转换Xcode项目以使用 Core Data。</p>
<h4 id="%E5%BB%BA%E7%AB%8B%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6%E5%99%A8-persistent-controller">建立持久控制器 Persistent Controller</h4>
<p>让我们首先建立一个名为<code>Persistence.swift</code>的新档案。 在项目导航器中，右键单击<em>Model</em>并使用 <em>Swift file</em> 模板。 将文件命名为<code>Persistence.swift</code>并在文件中插入以下代码：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">import</span> <span class="hljs-type">CoreData</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PersistenceController</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">PersistenceController</span>()

    <span class="hljs-keyword">let</span> container: <span class="hljs-type">NSPersistentContainer</span>

    <span class="hljs-keyword">init</span>(inMemory: <span class="hljs-type">Bool</span> = <span class="hljs-built_in">false</span>) {
        container = <span class="hljs-type">NSPersistentContainer</span>(name: <span class="hljs-string">&quot;ToDoList&quot;</span>)
        <span class="hljs-keyword">if</span> inMemory {
            container.persistentStoreDescriptions.first!.url = <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-string">&quot;/dev/null&quot;</span>)
        }
        container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>? {
                <span class="hljs-comment">// Replace this implementation with code to handle the error appropriately.</span>
                <span class="hljs-comment">// fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>

                <span class="hljs-comment">/*
                Typical reasons for an error here include:
                * The parent directory does not exist, cannot be created, or disallows writing.
                * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                * The device is out of space.
                * The store could not be migrated to the current model version.
                Check the error message to determine what the actual problem was.
                */</span>
                fatalError(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(error)</span>, <span class="hljs-subst">\(error.userInfo)</span>&quot;</span>)
            }
        })
    }
}
</code></pre>
<p>以上的代码你应该很熟悉，因为它和Xcode生成的代码是一样的，只是容器的名字改成了<em>ToDo List</em>。</p>
<h4 id="%E6%B3%A8%E5%85%A5%E8%A8%97%E7%AE%A1%E7%89%A9%E4%BB%B6%E5%85%A7%E5%AE%B9%EF%BC%88managed-object-context%EF%BC%89">注入托管物件内容（Managed Object Context）</h4>
<p>现在打开<code>ToDoListApp.swift</code> 并将托管物件内容注入到环境中。 在 <code>ToDoListApp</code> 中，建立以下变数以保存 <code>PersistenceController</code>：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> persistenceController = <span class="hljs-type">PersistenceController</span>.shared
</code></pre>
<p>接下来，在同一个档案中，将 <code>environment</code> 修饰器附加到 <code>ContentView()</code>，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-type">ContentView</span>()
    .environment(\.managedObjectContext, persistenceController.container.viewContext)
</code></pre>
<p>在上面的代码中，我们将托管物件内容注入到 <code>ContentView</code> 的环境中。 这使我们可以轻松地从内容视图中取得这个托管物件内容以管理数据库中的数据。</p>
<h4 id="%E5%BB%BA%E7%AB%8B%E8%A8%97%E7%AE%A1%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B">建立托管物件模型</h4>
<p>接下来，我们需要手动建立托管物件模型。 在项目导航器中，右键单击 <em>ToDoList</em> 文件夹并选择 <em>New file...</em>。 选择 <em>Data Model</em> 并将文件命名为“ToDoList.xcdatamodeld”。 请确保你正确命名文件，因为它应该与<code>NSPersistentContainer</code>内的名称相同。</p>
<figure id="fig22.7"><img src="images/core-data/swiftui-core-data-7.png" alt="图 22.7. 选择数据模型模板"><figcaption>图 22.7. 选择数据模型模板</figcaption></figure>
<p>之后，选择模型文件并单击 <em>Add Entity</em> 以建立新实体。 将实体的名称从 <em>Entity</em> 更改为 <em>ToDoItem</em>。 你可以将此实体视为数据库表中的一条记录。 因此，该实体应存储“ToDoItem”的属性。 我们需要为实体添加 4 个属性，包括（见图 22.8）：</p>
<ul>
<li><em>id</em> - 类型为 <em>UUID</em></li>
<li><em>name</em> - 类型为 <em>String</em></li>
<li><em>priorityNum</em> - 类型为 <em>Integer 32</em></li>
<li><em>isComplete</em> - 类型为 <em>Boolean</em></li>
</ul>
<p><code>id</code>、<code>name</code> 和 <code>isComplete</code> 的类型与 <code>ToDoItem</code> 类的类型完全相同。 但是为什么优先次序设置为 <em>Integer 32</em> 类型？ 如果你看一下 <code>ToDoItem.swift</code> 中的代码，你会看到 <em>priority</em> 属性是一个Enum：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Priority</span>: <span class="hljs-title">Int</span> </span>{
    <span class="hljs-keyword">case</span> low = <span class="hljs-number">0</span>
    <span class="hljs-keyword">case</span> normal = <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> high = <span class="hljs-number">2</span>
}
</code></pre>
<p>要将这个Enum保存到数据库中，我们必须存储它的原始值，它是一个整数。 这就是我们使用 <em>Integer 32</em> 类型并将属性命名为 <em>priorityNum</em> 以避免命名冲突的原因。</p>
<p>在预设的情况下，Xcode 会自动生成这个 <code>ToDoItem</code> 实体的模型类。 但是，我更喜欢手动建立这个类型，以便有更好地控制。 因此，选择 <code>ToDoItem</code> 实体并打开 <em>Data Model Inspector</em>。 如果你看不到检查器，请转到菜单并选择 <em>View</em> &gt; <em>Inspectors</em> &gt; <em>Show Data Model Inspector</em>。 在 <em>Class</em> 部分，将 <em>Module</em> 设置为 <em>Current Product Module</em>，将 <em>Codegen</em> 设置为 <em>Manual/None</em>。 这将禁止Xcode 自动生成代码。</p>
<figure id="fig22.8"><img src="images/core-data/swiftui-core-data-8.png" alt="图 8. 禁用代码生成"><figcaption>图 8. 禁用代码生成</figcaption></figure>
<p>如你所见，到目前为止我们开发的所有内容都不需要你具备数据库编程知识。 没有 SQL，没有数据库表。 你处理的所有事情都是基于对象的， 这就是 Core Data 的美妙之处。</p>
<h4 id="%E5%AE%9A%E7%BE%A9%E6%A8%A1%E5%9E%8B%E9%A1%9E%E5%88%A5">定义模型类别</h4>
<p>在 Core Data 中，每个实体都应该与一个模型类配对。 默认情况下，这个模型类是由 Xcode 生成的。 之前，我们把设置从 <em>code gen</em> 更改为 <em>manual</em>。 所以，我们需要手动建立模型类型<code>ToDoItem</code>。 切换到 <code>ToDoItem.swift</code> 并导入 <em>CoreData</em> 包：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">import</span> <span class="hljs-type">CoreData</span>
</code></pre>
<p>像这样建立<code>ToDoItem</code>类别：</p>
<pre><code class="lang-swift">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToDoItem</span>: <span class="hljs-title">NSManagedObject</span> </span>{
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> id: <span class="hljs-type">UUID</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> priorityNum: <span class="hljs-type">Int32</span>
    <span class="hljs-preprocessor">@NSManaged</span> public <span class="hljs-keyword">var</span> isComplete: <span class="hljs-type">Bool</span>
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ToDoItem</span>: <span class="hljs-title">Identifiable</span> </span>{

    <span class="hljs-keyword">var</span> priority: <span class="hljs-type">Priority</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-type">Priority</span>(rawValue: <span class="hljs-type">Int</span>(priorityNum)) ?? .normal
        }

        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.priorityNum = <span class="hljs-type">Int32</span>(newValue.rawValue)
        }
    }
}
</code></pre>
<p>Core Data 的模型类别应该继承自<code>NSManagedObject</code>。 每个属性都用<code>@NSManaged</code> 注释，并对应于我们之前建立的 Core Data 模型的属性。 通过使用<code>@NSManaged</code>，这告诉编译器该属性是由Core Data 处理。</p>
<p>在 <code>ToDoItem</code> 的原始版本中，我们有一个类型为 Enum 的 <code>priority</code> 属性。 对于 Core Data 版本，我们必须为<code>priority</code>建立一个计算属性（Computed Property）。 此计算属性将优先次序的编号转换为 Enum，反之亦然。</p>
<h4 id="%E5%88%A9%E7%94%A8-fetchrequest-%E5%8F%96%E5%BE%97%E8%B3%87%E6%96%99">利用 @FetchRequest 取得资料</h4>
<p>现在我们已经准备好了模型类别，让我们看看从数据库中获取记录是多么容易。 切换到<code>ContentView.swift</code>。 最初，我们有一个包含所有待办事项的阵列变数，它也标有<code>@State</code>：</p>
<pre><code class="lang-swift">@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> todoItems: [<span class="hljs-type">ToDoItem</span>] = []
</code></pre>
<p>由于我们要在数据库中存储项目，我们需要修改这行代码并从中获取数据。 Apple 引入了一个名为 <code>@FetchRequest</code> 的新属性包装器，让开发者更容易从数据库拿取数据。</p>
<p>将上面的代码改为 <code>@FetchRequest</code>，如下所示：</p>
<pre><code class="lang-swift">@<span class="hljs-type">FetchRequest</span>(
    entity: <span class="hljs-type">ToDoItem</span>.entity(),
    sortDescriptors: [ <span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">ToDoItem</span>.priorityNum, ascending: <span class="hljs-built_in">false</span>) ])
<span class="hljs-keyword">var</span> todoItems: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">ToDoItem</span>&gt;
</code></pre>
<p>回想一下，我们已经在环境中注入了托管物件内容，这个读取请求会自动利用托管物件内容以获取所需的数据。 在上面的代码中，我们指定获取 <code>ToDoItem</code> 实体以及结果的排序方式。 另外，我们想根据优先次序对各事项进行排序。</p>
<p>获取完成后，你将拥有一组 <code>ToDoItem</code> 托管物件，这些物件是建基于我们之前在模型层中定义的 <code>ToDoItem</code> 类别。</p>
<p>这就是从数据库中检索数据的方式。 而且，由于 <code>ToDoItem</code> 的属性保持不变，我们不需要为列表视图做任何代码更改，就可以直接在 ForEach 中使用所得的数据：</p>
<pre><code class="lang-swift"><span class="hljs-type">List</span> {

    <span class="hljs-type">ForEach</span>(todoItems) { todoItem <span class="hljs-keyword">in</span>
        <span class="hljs-type">ToDoListRow</span>(todoItem: todoItem)
    }

}
</code></pre>
<p>最重要的是，你可以直接传递 <code>todoItem</code>，因为它就是一个 <code>NSManageObject</code>。看一看<code>NSManagedObject</code> 的技术文， 它符合<code>ObservableObject</code>。 这就是为什么我们可以直接将 <code>todoItem</code> 传递给 <code>ToDoListRow</code>。</p>
<figure id="fig22.9"><img src="images/core-data/swiftui-core-data-9.png" alt="Figure 9. NSManagedObject documentation"><figcaption>Figure 9. NSManagedObject documentation</figcaption></figure>
<p>还有一件事。 你可能还想知道我们是否需要在 <code>todoItems</code> 发生更改时手动执行 fetch 请求（例如，我们添加了一个新项目）。 这是使用<code>@FetchRequest</code> 的另一个优点。 SwiftUI 会自动管理其变动并相应地更新 UI。</p>
<h4 id="%E5%B0%87%E6%95%B8%E6%93%9A%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%8C%81%E4%B9%85%E5%AD%98%E5%84%B2">将数据添加到持久存储</h4>
<p>现在，让我们继续进行 Core Data 迁移并更新 <code>NewToDoView.swift</code> 的代码。 要在数据库中存新事项，首先需要从环境中获取托管物件内容：</p>
<pre><code class="lang-swift">@<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> context
</code></pre>
<p>由于我们不再使用阵列来保存待办事项，你可以删除这行代码：</p>
<pre><code class="lang-swift">@<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> todoItems: [<span class="hljs-type">ToDoItem</span>]
</code></pre>
<p>接下来，让我们像这样更新 <code>addTask</code> 函数：</p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">addTask</span><span class="hljs-params">(name: String, priority: Priority, isComplete: Bool = <span class="hljs-built_in">false</span>)</span> </span>{

    <span class="hljs-keyword">let</span> task = <span class="hljs-type">ToDoItem</span>(context: context)
    task.id = <span class="hljs-type">UUID</span>()
    task.name = name
    task.priority = priority
    task.isComplete = isComplete

    <span class="hljs-keyword">do</span> {
        try context.save()
    } catch {
        <span class="hljs-built_in">print</span>(error)
    }
}
</code></pre>
<p>要将新记录加入数据库，你需要使用托管物件内容建立一个 <code>ToDoItem</code>，然后呼叫 <code>save()</code> 方法来储存更改。</p>
<p>由于我们移除了 <code>todoItems</code> 绑定，我们需要更新预览代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewToDoView_Previews</span>: <span class="hljs-title">PreviewProvider</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NewToDoView</span>(isShow: .constant(<span class="hljs-built_in">true</span>), name: <span class="hljs-string">&quot;&quot;</span>, priority: .normal)
    }
}
</code></pre>
<p>现在让我们回到<code>ContentView.swift</code>。 同样地，你应该会在<code>ContentView</code>中看到一个错误（见图 22.10）。</p>
<figure id="fig22.10"><img src="images/core-data/swiftui-core-data-10.png" alt="图 22.10. Xcode 向你显示 ContentView 中的错误"><figcaption>图 22.10. Xcode 向你显示 ContentView 中的错误</figcaption></figure>
<p>像这样更改代码行以修复错误：</p>
<pre><code class="lang-swift"><span class="hljs-type">NewToDoView</span>(isShow: $showNewTask, name: <span class="hljs-string">&quot;&quot;</span>, priority: .normal)
</code></pre>
<p>我们只需删除 <code>todoItems</code> 参数。 这就是我们将范例App从使用阵列存储转换为持久存储的方式。</p>
<h4 id="%E6%9B%B4%E6%96%B0%E7%8F%BE%E6%9C%89%E9%A0%85%E7%9B%AE">更新现有项目</h4>
<p>当你将项目标记为完成时，App应将这个更新储存在数据库中。 在 <code>ContentView.swift</code> ，找到 <code>ToDoListRow</code> 结构并加入以下变数：</p>
<pre><code class="lang-swift">@<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> context
</code></pre>
<p>和添加新记录类似，我们也需要先取得管理物件内容以进行更新。 在 <code>Toggle</code> 视图，加入 <code>onReceive</code> 修饰器并将其放在 <code>.toggleStyle(CheckboxStyle())</code> 之后，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    <span class="hljs-type">Toggle</span>(isOn: <span class="hljs-keyword">self</span>.$todoItem.isComplete) {
       .
       .
       .
    }
    .toggleStyle(<span class="hljs-type">CheckboxStyle</span>())
    <span class="hljs-comment">// 加入以下代码</span>
    .onChange(of: todoItem, perform: { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.context.hasChanges {
            try? <span class="hljs-keyword">self</span>.context.save()
        }
    })
}
</code></pre>
<p>每当切换发生更改时，<code>todoItem</code> 的 <code>isComplete</code> 属性都会更新。 但是，我们如何将它保存到数据库呢？ 回想一下 <code>todoItem</code> 已符合 <code>ObservableObject</code>，这意味着它有一个发布者来广播值的变化。</p>
<p><code>onChange</code> 修饰器则监听这些变化（比如<code>isComplete</code> 的变化），并通过调用<code>context</code>的 <code>save()</code> 方法将它们保存到数据库中。</p>
<p>现在你可以在模拟器中运行App进行测试， 你应该能够添加新事项。 添加新事项后，它们应立即显示在列表视图中。 核取方块也应该可以用了，点一下就可以将相关事项画线。 最重要的是，所有改动现在都永久保存在装置内的数据库。 就算重新App，所有项目仍然存在。</p>
<figure id="fig22.11"><img src="images/core-data/swiftui-core-data-11.png" alt="图 22.11. ToDo App 现在支援 Core Data"><figcaption>图 22.11. ToDo App 现在支援 Core Data</figcaption></figure>
<h4 id="%E5%BE%9E%E6%95%B8%E6%93%9A%E5%BA%AB%E4%B8%AD%E5%88%AA%E9%99%A4%E9%A0%85%E7%9B%AE">从数据库中删除项目</h4>
<p>既然我已经向你展示如何从数据库取出数据、更新和加入新项目，那么如何实作删除功能呢？ 我们将会为App添加一项功能 - 删除待办事项。</p>
<p>在 <code>ContentView</code> 结构中，宣告一个 <code>context</code> 变数：</p>
<pre><code class="lang-swift">@<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> context
</code></pre>
<p>然后添加一个名为<code>deleteTask</code>的函数，如下所示：</p>
<pre><code class="lang-swift">private <span class="hljs-func"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteTask</span><span class="hljs-params">(indexSet: IndexSet)</span> </span>{
    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indexSet {
        <span class="hljs-keyword">let</span> itemToDelete = todoItems[index]
        context.delete(itemToDelete)
    }

    <span class="hljs-type">DispatchQueue</span>.main.async {
        <span class="hljs-keyword">do</span> {
            try context.save()

        } catch {
            <span class="hljs-built_in">print</span>(error)
        }
    }
}
</code></pre>
<p>此函数接收一个索引集，该集储存要删除项目的索引。 要从数据库中删除项目，你可以呼叫<code>context</code>的<code>delete</code> 方法并指定要删除的项目。 最后，呼叫 <code>save()</code> 来执行更改。</p>
<p>既然我们已经准备好了删除方法，那么我们应该在哪里呼叫它呢？ 将 <code>onDelete</code> 修饰器附加到列表视图的 <code>ForEach</code>，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-type">List</span> {

    <span class="hljs-type">ForEach</span>(todoItems) { todoItem <span class="hljs-keyword">in</span>
        <span class="hljs-type">ToDoListRow</span>(todoItem: todoItem)
    }
    .onDelete(perform: deleteTask)

}
</code></pre>
<p><code>onDelete</code> 修饰器自动启用列表视图中的滑动删除功能。 当用户删除一个项目时，我们调用<code>deleteTask</code> 方法从数据库中删除该项目。</p>
<p>执行App并试试删除一个项目，按delete钮就可以将其从数据库中完全删除。</p>
<figure id="fig22.12"><img src="images/core-data/swiftui-core-data-12.png" alt="图 22.12. 删除一个项目"><figcaption>图 22.12. 删除一个项目</figcaption></figure>
<h3 id="%E4%BD%BF%E7%94%A8-swiftui-%E9%A0%90%E8%A6%A7">使用 SwiftUI 预览</h3>
<p>不知你有没有留意，现在Xcode内的SwiftUI预览已经不能正常显示预览。 这是可以理解的，因为我们没有在 <code>ContentView_Previews</code> 结构中注入托管物件内容（managed object context）。 那么，我们要如何解决问题并使预览正常运作？</p>
<p>首先，我们需要建立一个数据暂存器（in-memory data store）并加入一些测试数据。 打开<code>Persistence.swift</code>并宣告一个静态变数，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> preview: <span class="hljs-type">PersistenceController</span> = {
    <span class="hljs-keyword">let</span> result = <span class="hljs-type">PersistenceController</span>(inMemory: <span class="hljs-built_in">true</span>)
    <span class="hljs-keyword">let</span> viewContext = result.container.viewContext

    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span> {
        <span class="hljs-keyword">let</span> newItem = <span class="hljs-type">ToDoItem</span>(context: viewContext)
        newItem.id = <span class="hljs-type">UUID</span>()
        newItem.name = <span class="hljs-string">&quot;To do item #<span class="hljs-subst">\(index)</span>&quot;</span>
        newItem.priority = .normal
        newItem.isComplete = <span class="hljs-built_in">false</span>
    }

    <span class="hljs-keyword">do</span> {
        try viewContext.save()
    } catch {
        <span class="hljs-keyword">let</span> nsError = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>
        fatalError(<span class="hljs-string">&quot;Unresolved error <span class="hljs-subst">\(nsError)</span>, <span class="hljs-subst">\(nsError.userInfo)</span>&quot;</span>)
    }

    <span class="hljs-keyword">return</span> result
}()
</code></pre>
<p>在以上的代码，我们建立了一个 <code>PersistenceController</code> 的实体，并将 <code>inMemory</code> 参数设置为 <code>true</code>。 然后，我们添加 10 个测试待办事项并将它们保存到数据暂存器。</p>
<p>现在让我们切换到 <code>ContentView.swift</code> 并像这样更新预览代码：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView_Previews</span>: <span class="hljs-title">PreviewProvider</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> previews: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ContentView</span>().environment(\.managedObjectContext, <span class="hljs-type">PersistenceController</span>.preview.container.viewContext)
    }
}
</code></pre>
<p>我们将数据暂存器的<code>context</code>注入到内容视图的环境中。 通过这样做，内容视图现在可以加载示例待办事项并将显示在预览画面中。</p>
<h3 id="%E7%B8%BD%E7%B5%90">总结</h3>
<p>在本章中，我们将 Todo 范例App加入永久储存数据功能。 我希望你现在了解如何在 SwiftUI 开发中使用 Core Data 并知道如何执行所有基本的 CRUD（建立、读取、更新和删除）操作。SwiftUI框架新加入的 <code>@FetchRequest</code> 属性包装器使得在数据库管理变得非常容易。</p>
<p>本章所讲解的范例以及最后完整的Xcode 专案：</p>
<p><a href="https://www.appcoda.com/resources/swiftui4/SwiftUIToDoList.zip" target="_blank">https://www.appcoda.com/resources/swiftui4/SwiftUIToDoList.zip</a></p>
<p>请自行下载以供你参考。</p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./swiftui-json.html" class="navigation navigation-prev " aria-label="Previous page: JSON、滑杆的运用与资料过滤"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./swiftui-uikit.html" class="navigation navigation-next " aria-label="Next page: 利用 UIViewRepresentable 整合UIKit 组件"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":"white","family":"serif","size":3},"image-captions":{"caption":"_CAPTION_","variable_name":"_pictures"}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
